<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: serverless | James Thomas]]></title>
  <link href="http://jamesthom.as/blog/categories/serverless/atom.xml" rel="self"/>
  <link href="http://jamesthom.as/"/>
  <updated>2016-11-28T16:34:37+00:00</updated>
  <id>http://jamesthom.as/</id>
  <author>
    <name><![CDATA[James Thomas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NPM Modules in OpenWhisk]]></title>
    <link href="http://jamesthom.as/blog/2016/11/28/npm-modules-in-openwhisk/"/>
    <updated>2016-11-28T14:03:00+00:00</updated>
    <id>http://jamesthom.as/blog/2016/11/28/npm-modules-in-openwhisk</id>
    <content type="html"><![CDATA[<p>OpenWhisk now <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/actions.md#packaging-an-action-as-a-nodejs-module">supports creating Node.js Actions from a zip file</a>. The archive file will be extracted into the runtime environment by the platform. This allows us to split microservice logic across multiple files, use third-party <a href="https://www.npmjs.com/">NPM modules</a> or include non-JavaScript assets (configuration files, images, HTML files).</p>

<h2>"Hello World" Example</h2>

<p>Let's look at a "Hello World" example of registering a serverless function from a zip file. Our archive will contain two files, the <a href="https://docs.npmjs.com/files/package.json">package descriptor</a> and a JavaScript file.</p>

<p>Here is the minimal <code>package.json</code> file required for loading a module from a directory.</p>

<p><code>json package.json
{
  "main": "my_file.js"
}
</code></p>

<p>In <code>my_file.js</code>, a function is returned through the <code>main</code> property on the <code>exports</code> object. This function <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/actions.md#creating-and-invoking-javascript-actions">implements the Action interface.</a></p>

<p><code>javascript my_file.js
exports.main = function (params) {
  return {result: "Hello World"};
};
</code></p>

<p>Creating a zip file from the current directory, we can deploy this Action through the command-line utility.</p>

<p><code>sh
$ zip -r action.zip *
$ wsk action create hello_world --kind nodejs:default action.zip
</code></p>

<p>When this Action is invoked, the archive will be unzipped into a temporary directory. OpenWhisk loads the directory as a Node.js module and invokes the function property on the module for each invocation.</p>

<p>``` sh
$ wsk action invoke hello_world --result
{</p>

<pre><code>"result": "Hello world"
</code></pre>

<p>}
```</p>

<h2>Using NPM Dependencies</h2>

<p>Let's look a more complicated example which uses an external <a href="https://www.npmjs.com/">NPM module</a> in our Action.</p>

<p>``` javascript index.js
const leftPad = require("left-pad")</p>

<p>function myAction(args) {</p>

<pre><code>const lines = args.lines || [];
return { padded: lines.map(l =&gt; leftPad(l, 30, ".")) }
</code></pre>

<p>}</p>

<p>exports.main = myAction;
```</p>

<p>This module uses the <a href="http://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/">extremely popular</a> <a href="https://www.npmjs.com/package/left-pad">left-pad</a> module to process an array of strings, passed through a request parameter. The resulting output is returned in the response.</p>

<p>Before using this module, we need to install the dependencies listed in <code>package.json</code>.</p>

<p>``` json
{
  "name": "my-action",
  "version": "1.0.0",
  "main": "index.js",
  "dependencies" : {</p>

<pre><code>"left-pad" : "1.1.3"
</code></pre>

<p>  }
}
```</p>

<p><strong>OpenWhisk does not automatically install dependencies listed in <code>package.json</code> in the runtime environment.</strong></p>

<p>The developer has to run <code>npm install</code> locally and include the <code>node_modules</code> directory in the zip file.</p>

<ul>
<li>Install NPM dependencies locally.</li>
</ul>


<p><code>sh
$ npm install
</code></p>

<ul>
<li>Create a <code>.zip</code> archive containing all files.</li>
</ul>


<p><code>sh
$ zip -r action.zip *
</code></p>

<ul>
<li>Create the action using command-line utility.</li>
</ul>


<p><code>sh
$ wsk action create packageAction --kind nodejs:default action.zip
</code></p>

<p>Now we can test out our action to check it works‚Ä¶.</p>

<p>``` sh
$ wsk action invoke --blocking --result packageAction --param lines "[\"and now\", \"for something completely\", \"different\" ]"
{</p>

<pre><code>"padded": [
    ".......................and now",
    "......for something completely",
    ".....................different"
]
</code></pre>

<p>}
```</p>

<h2>Native Module Dependencies</h2>

<p>Node.js provides a mechanism for JavaScript modules to <a href="https://nodejs.org/api/addons.html">include native platform code</a> as if they were ordinary modules. This is often used to improve performance by deferring operations to native C/C++ libraries. NPM handles compiling native code during the dependency install process.</p>

<p><strong>Using modules with native dependencies in Actions requires the native code to be compiled for the platform runtime.</strong></p>

<h3>Compiling dependencies with Docker</h3>

<p>One solution to this problem uses Docker to simulate the same runtime environment.</p>

<p>OpenWhisk uses Docker to manage the runtime environments for Actions. The <a href="https://github.com/docker-library/buildpack-deps/blob/af914a5bde2a749884177393c8140384048dc5f9/trusty/curl/Dockerfile"><em>buildpack-deps:trusty-curl</em></a> image is used as the <a href="https://github.com/openwhisk/openwhisk/blob/master/core/nodejsActionBase/Dockerfile">base image for all Node.js Actions</a>.</p>

<p>Running a local container from this image will give access to the same runtime environment. Running <code>npm install</code> within this container will produce the <code>node_modules</code> directory with native code compiled for the correct architecture.</p>

<h3>Action With Native Modules</h3>

<p>Let's look at an example‚Ä¶</p>

<p>``` javascript index.js
const SHA3 = require('sha3');</p>

<p>function SHA(args) {
  const d = new SHA3.SHA3Hash();
  d.update(args.payload);
  return { sha: d.digest('hex') };
}</p>

<p>exports.main = SHA;
```</p>

<p>This module returns a function that calculates a SHA3 cryptographic hash for the invocation payload. The hex string for the hash is returned as the function response.</p>

<p>The NPM module (<a href="https://www.npmjs.com/package/sha3">sha3</a>) used to calculate the digest uses a C++ extension for the hashing algorithm.</p>

<p>``` json package.json
{
  "name": "hashing-service",
  "version": "1.0.0",
  "main": "index.js",
  "dependencies": {</p>

<pre><code>"sha3": "^1.2.0"
</code></pre>

<p>  }
}
```</p>

<h3>Action Runtime Environments</h3>

<p>OpenWhisk uses a <a href="https://github.com/docker-library/buildpack-deps/blob/af914a5bde2a749884177393c8140384048dc5f9/trusty/curl/Dockerfile">public Docker image</a> as the base image for the Action environments. It then <a href="https://github.com/openwhisk/openwhisk/blob/master/core/nodejs6Action/Dockerfile">builds a custom image</a> by installing Node.js and NPM for the particular runtime version.</p>

<p>Rather than building this image ourselves, we can use existing images published on <a href="https://hub.docker.com/">Docker Hub</a>.</p>

<p><a href="https://nodesource.com/">NodeSource</a> provides <a href="https://hub.docker.com/u/nodesource/">public Docker images pre-installed with different Node.js versions</a>. Provided the base image (Ubuntu Trusty) and Node.js version (6.7) matches, the runtime environment will be the same.</p>

<p>Starting a local container from this image, we can use Docker's <a href="https://docs.docker.com/engine/tutorials/dockervolumes/">host volume support</a> to mount the local directory into the host container.</p>

<p><code>sh
$ docker run -it -v "/action:/usr/src/app" nodesource/trusty:6.7 /bin/sh
</code></p>

<p>Running <code>npm install</code> in the container, the <code>sha3</code> dependency is compiled and installed.</p>

<p>``` sh</p>

<h1>npm install</h1>

<blockquote><p>sha3@1.2.0 install /usr/src/app/node_modules/sha3                                                                 <br/>
node-gyp rebuild</p></blockquote>

<p>make: Entering directory <code>/usr/src/app/node_modules/sha3/build'                                                       
make: Warning: File</code>sha3.target.mk' has modification time 0.19 s in the future                                     <br/>
  CXX(target) Release/obj.target/sha3/src/addon.o                                                                   <br/>
  CXX(target) Release/obj.target/sha3/src/displayIntermediateValues.o                                               <br/>
  CXX(target) Release/obj.target/sha3/src/KeccakF-1600-reference.o                                                  <br/>
  CXX(target) Release/obj.target/sha3/src/KeccakNISTInterface.o                                                     <br/>
  CXX(target) Release/obj.target/sha3/src/KeccakSponge.o                                                            <br/>
  SOLINK_MODULE(target) Release/obj.target/sha3.node                                                                <br/>
  COPY Release/sha3.node                                                                                            <br/>
make: warning:  Clock skew detected.  Your build may be incomplete.                                                 <br/>
make: Leaving directory <code>/usr/src/app/node_modules/sha3/build'                                                        
my-action@1.0.0 /usr/src/app                                                                                          
</code>-- sha3@1.2.0                                                                                                      <br/>
  `-- nan@2.4.0</p>

<p>```</p>

<p>The <code>node_modules</code> directory will be available on the host system after exiting the container. Repeat the steps above to archive the source files and deploy our serverless function.</p>

<p><code>sh
$ zip -r action.zip *
$ wsk action create packageAction --kind nodejs:6 action.zip  
ok: created action packageAction          
</code></p>

<p>Invoking the Action will now use the native code to produce hash values for the invocation parameters.</p>

<p>``` sh
$ wsk action invoke packageAction -b -p payload "Hello" --result                            <br/>
{</p>

<pre><code>"sha": "c33fede18a1ae53ddb8663710f8054866beb714044fce759790459996196f101d94dfc7bd8268577f7ee3d2f8ff0cef4004a963222
</code></pre>

<p>7db84df62d2b40682d69e2"                                                                                             <br/>
}                     <br/>
```</p>

<h2>Action Package Details</h2>

<p>Upon invocation, OpenWhisk extracts the action's zip file to a temporary directory in the runtime environment. It then <a href="https://nodejs.org/api/modules.html#modules_all_together">loads the directory as a standard Node.js module</a>, using <code>require</code>.</p>

<p>Node.js expects the directory to have a valid <code>package.json</code> file. The <code>main</code> property is used to define which JavaScript file is evaluated when the module is loaded. This file can assign values to the global <code>exports</code> object. These references are then returned when <code>require</code> is called for this module.</p>

<p><strong>OpenWhisk expects the returned module object to have a property called <code>main</code> which references a function. This function will be executed for each invocation request.</strong></p>

<p>Request parameters are passed as object properties on the first function argument. The function must return an object for the invocation response.</p>

<p>Other files included in the archive will be available in the current working directory. These can also be loaded as modules or read directly from the file-system.</p>

<h2>Conclusions</h2>

<p>OpenWhisk support for Action packages is a huge step forward for the platform. Node.js has an enormous ecosystem of third-party modules. Developers can now easily use any of these modules within their Actions.</p>

<p>This feature can also be used to include non-JS files within the runtime environment. It would be possible to use configuration files in JSON or static assets like HTML or CSS files.</p>

<p><strong><em>The team are now working on providing support for other runtimes, watch this space‚Ä¶</em></strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Serverless Logs With Elasticsearch]]></title>
    <link href="http://jamesthom.as/blog/2016/10/31/serverless-logs-with-elasticsearch/"/>
    <updated>2016-10-31T10:39:00+00:00</updated>
    <id>http://jamesthom.as/blog/2016/10/31/serverless-logs-with-elasticsearch</id>
    <content type="html"><![CDATA[<p><a href="http://martinfowler.com/articles/serverless.html">Serverless platforms</a> can seem like magic.</p>

<p>Taking your code and turning it into scalable microservices in the cloud without having to set up or manage any infrastructure.</p>

<p><em>No provisioning VMs. No configuring Linux environments. No upgrading middleware packages.</em></p>

<p>Which is wonderful until something goes wrong with your microservices in production‚Ä¶</p>

<p><em>"Let me just log into the machine."</em></p>

<p><strong>Serverless platforms do not allow this.</strong></p>

<p><em>No tracing system calls. No running top. No connecting a debugger to the process. You can't even grep through the logs!</em></p>

<p>Many of the tools and techniques we use to diagnose bugs rely on having access to the environment.</p>

<p><em>Fortunately, we do still have access to logging output generated by our serverless functions. Phew.</em></p>

<p><strong>Storing, searching and analysing these logs is crucial to efficiently diagnosing and fixing issues on serverless platforms.</strong></p>

<p>In this blog post, we're going to look at using a popular open-source solution to manage the logs being generated by our serverless functions. This solution is also known as "<a href="https://www.oreilly.com/ideas/understanding-the-elk-stack">The ELK Stack</a>".</p>

<p><strong><em>TLDR: There is now a Logstash input plugin for OpenWhisk. This will automatically index serverless application logs into Elasticsearch. See here for usage instructions: <a href="https://github.com/jthomas/logstash-input-openwhisk">https://github.com/jthomas/logstash-input-openwhisk</a></em></strong></p>

<h2>Elasticsearch, Logstash and Kibana</h2>

<p>‚Ä¶are the three open-source projects that, when combined, are known as The ELK Stack. It provides a scalable search engine for indexed documents.</p>

<p><a href="https://github.com/elastic/elasticsearch">Elasticsearch</a> <em>"is a search engine based on Lucene. It provides a distributed, multitenant-capable full-text search engine with an HTTP web interface and schema-free JSON documents."</em></p>

<p><a href="https://github.com/elastic/logstash">Logstash</a> is a tool for managing events and logs. You can use it to collect logs, parse them, and store them for later use (like, for searching). If you store them in Elasticsearch, you can view and analyze them with Kibana.</p>

<p><a href="https://github.com/elastic/kibana">Kibana</a> is an open source analytics and visualization platform designed to work with Elasticsearch. You use Kibana to search, view, and interact with data stored in Elasticsearch.</p>

<p>The ELK Stack is a perfect solution for managing logs from our serverless functions.</p>

<p><strong>But how do we configure this solution to automatically index logs from our serverless platform?</strong></p>

<p><em>Let's start by looking serverless platform we are using‚Ä¶</em></p>

<h2>OpenWhisk</h2>

<p><a href="https://github.com/openwhisk/openwhisk">OpenWhisk</a> is an open-source serverless platform developed by IBM. Developers <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/actions.md">deploy functions</a> to execute in response to <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/triggers_rules.md">external events</a>, e.g. database updates, messages on a queue or HTTP requests. The platform invokes these functions on-demand in milliseconds, rather than having services sat idle waiting for requests to arrive.</p>

<p><em>Let's walk through an example.</em></p>

<h3>Serverless Functions</h3>

<p>Here's a sample serverless function which returns a greeting to the user. The code logs the invocation parameters and response message.</p>

<p>``` javascript logs.js
function main (params) {
  console.log('invoked with parameters:', params)</p>

<p>  const user = params.user || 'Donald Trump'
  const response = { greeting: <code>Hello ${user}</code> }</p>

<p>  console.log('returns: ', response)
  return response
}
```</p>

<p>Deploying this serverless function to OpenWhisk and invoking it generates an activation record.</p>

<p>``` sh
$ wsk action create logs logs.js
ok: created action logs
$ wsk action invoke logs -b -r -p user 'Bernie Sanders'
{</p>

<pre><code>"greeting": "Hello Bernie Sanders"
</code></pre>

<p>}
$ wsk activation list
activations
2adbbbcc0242457f80dc51944dcd2039                 logs
...
```</p>

<p>OpenWhisk activation records are available through the <a href="http://petstore.swagger.io/?url=https://raw.githubusercontent.com/openwhisk/openwhisk/master/core/controller/src/main/resources/whiskswagger.json">platform API</a>. Each record contains the stdout and stderr logs generated during the serverless function invocation.</p>

<h3>Serverless Logs</h3>

<p>Retrieving the activation record for the previous invocation, we can see the output generated by the calls to <code>console.log</code>.</p>

<p>``` sh
$ wsk activation get 2adbbbcc0242457f80dc51944dcd2039
ok: got activation 2adbbbcc0242457f80dc51944dcd2039
{</p>

<pre><code>"namespace": "james.thomas@uk.ibm.com",
"name": "logs",
"version": "0.0.3",
"publish": false,
"subject": "james.thomas@uk.ibm.com",
"activationId": "2adbbbcc0242457f80dc51944dcd2039",
"start": 1477925373990,
"end": 1477925374063,
"response": {
    "status": "success",
    "statusCode": 0,
    "success": true,
    "result": {
        "greeting": "Hello Bernie Sanders"
    }
},
"logs": [
    "2016-10-31T14:49:34.059745626Z stdout: invoked with parameters: {}",
    "2016-10-31T14:49:34.061228724Z stdout: returns:  { greeting: 'Hello Donald Trump' }"
],
...
</code></pre>

<p>}
```</p>

<p>OpenWhisk stores these records indefinitely, making them available for <a href="http://petstore.swagger.io/?url=https://raw.githubusercontent.com/openwhisk/openwhisk/master/core/controller/src/main/resources/whiskswagger.json#!/Activations/getActivationById">retrieval by the activation id</a>.</p>

<p>However, developers need more than being able to retrieve logs to be effective at diagnosing and resolving issues with serverless functions.</p>

<p>Forwarding these logs to Elasticsearch will enable us to run full-text search across all logs generated, quickly retrieve all output for a particular serverless function, set up monitoring dashboards and much more‚Ä¶</p>

<p>Using Logstash will allow us to ingest and transform OpenWhisk logs into Elasticsearch documents.</p>

<h2>Logstash Input Plugins</h2>

<p>Logstash supports a huge variety of event sources through the use of a <a href="https://www.elastic.co/guide/en/logstash/current/working-with-plugins.html">plugin mechanism</a>. These plugins handle retrieving the external events and converting them to Elasticsearch documents.</p>

<p>Logstash has a huge repository of <a href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html">official and community supported input plugins</a>. These plugins ingest everything from log files, syslog streams, databases, message queues, websockets and much more.</p>

<h3>HTTP Polling Input Plugin</h3>

<p>Logstash already has an input plugin for <a href="https://github.com/logstash-plugins/logstash-input-http_poller">pulling events from a HTTP URL by polling</a>. Users provide the URL in the logstash configuration, along with the polling schedule. Logstash will automatically retrieve and ingest the JSON response as an event stream.</p>

<p>```
input {
  http_poller {</p>

<pre><code>urls =&gt; {
  "my_events" =&gt; "http://localhost:8000/events"
}
# Poll site every 10s
interval =&gt; 10
request_timeout =&gt; 60
codec =&gt; "json"
</code></pre>

<p>  }
}
```</p>

<p><em>Great, so we can configure this plugin to call OpenWhisk API for retrieving activation records and automatically ingest them into Elasticsearch?</em></p>

<p>Unfortunately not...</p>

<h3>Polling OpenWhisk Logs?</h3>

<p>Each time the client calls the API to retrieve the activation records, we want to retrieve only those records that have occurred since the last poll. This ensures we are not ingesting the same records more than once.</p>

<p>The <a href="http://petstore.swagger.io/?url=https://raw.githubusercontent.com/openwhisk/openwhisk/master/core/controller/src/main/resources/whiskswagger.json#!/Activations/getActivations">OpenWhisk API for retrieving activation records</a> supports a query parameter (<code>since</code>) which restricts results to those that occurred after the parameter value's timestamp.</p>

<p>Using this parameter in the polling URL, updated to the value of the last polling time, will allow us to ensure we only retrieve new activation records.</p>

<p><strong>Unfortunately, the HTTP input plugin does not support setting dynamic query string parameters.</strong></p>

<p>This means we cannot use the existing plugin to efficiently ingest OpenWhisk logs into Elasticsearch.</p>

<p><em>So we started work on a new plugin to support this behaviour‚Ä¶</em></p>

<h3>OpenWhisk Input Plugin</h3>

<p>This <a href="https://github.com/jthomas/logstash-input-openwhisk">input plugin</a> drains logs from OpenWhisk into Elasticsearch.</p>

<p>Install the plugin with the following command.</p>

<p><code>sh
$ bin/logstash-plugin install logstash-input-openwhisk
</code></p>

<p>Once the plugin is installed, you need to configure Logstash with your platform endpoint and user credentials.</p>

<p>This sample configuration will poll the OpenWhisk platform for new logs every fifteen minutes and index them into Elasticsearch. Each activation record will be a separate document.</p>

<p>```
input {
  openwhisk {</p>

<pre><code># Mandatory Configuration Parameters
hostname =&gt; "openwhisk.ng.bluemix.net"
username =&gt; "sample_user@email.com"
password =&gt; "some_password"
# Supports "cron", "every", "at" and "in" schedules by rufus scheduler
schedule =&gt; { "every" =&gt; "15m"}
</code></pre>

<p>  }
}</p>

<p>output {
  elasticsearch {</p>

<pre><code>hosts =&gt; ["localhost:9200"]
</code></pre>

<p>  }
}
```</p>

<p>The plugin supports the same configuration values for the <code>schedule</code> parameter as the <a href="https://github.com/logstash-plugins/logstash-input-http_poller">HTTP input plugin</a>.</p>

<p>More examples of using the plugin are available in the <a href="https://github.com/jthomas/logstash-input-openwhisk/tree/master/examples">examples</a> directory in the project repository.</p>

<h2>Demonstration</h2>

<p>Here's a demonstration of the OpenWhisk input plugin being used in the ELK stack. As we invoke serverless functions in OpenWhisk, Kibana shows the activation records appearing in the dashboard. Logstash is polling the logs API and ingesting the records into Elasticsearch in real-time.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/9gNyrW58EqE" frameborder="0" allowfullscreen></iframe>


<h2>Conclusion</h2>

<p>Developers using serverless platforms have no access to the infrastructure environment running their code. Debugging production bugs relies on using logging output to diagnose and resolve issues.</p>

<p>Elasticsearch, Logstash and Kibana has become the scalable open-source solution for log management and analysis.</p>

<p>Using the <a href="https://github.com/jthomas/logstash-input-openwhisk">Logstash plugin for OpenWhisk</a>, serverless logs will be automatically indexed into Elasticsearch in real-time. Developers can use the Kibana frontend to easily diagnose and monitor issues in production.</p>

<p>In the next post, we'll look at using Docker to set up Elasticsearch, Logstash and Kibana with our custom OpenWhisk plugin.</p>

<p>Until then... üòé</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenWhisk Workshop]]></title>
    <link href="http://jamesthom.as/blog/2016/10/10/openwhisk-workshop/"/>
    <updated>2016-10-10T14:51:00+01:00</updated>
    <id>http://jamesthom.as/blog/2016/10/10/openwhisk-workshop</id>
    <content type="html"><![CDATA[<p><img src="https://dl.dropboxusercontent.com/u/10404736/serverless_ldn.png" alt="serverless london" /></p>

<p><a href="http://serverlessconf.io/">Serverless Conference</a> comes to London <a href="http://london.serverlessconf.io/">later this month</a>.</p>

<p>IBM will be hosting a full-day workshop at the event. Developers can come and learn how to use <a href="https://github.com/openwhisk/openwhisk">OpenWhisk</a>, the open-source serverless platform.</p>

<p>I'm going to be one of the mentors on the day, along with members from the product team.</p>

<p>Working on training material for the session, I remembered that the Node.js community had a popular workshop tool for running training sessions around the world.</p>

<h2>NodeSchool</h2>

<p><a href="http://nodeschool.io/">NodeSchool</a>¬†provides developers with a command-line utility that helps them learn the platform.¬†This tool provides a¬†series of interactive exercises to test their knowledge. Each exercise requires the developers to write some code. The application can then verify their solution and record¬†their progress.</p>

<p>The Node.js community <a href="https://github.com/workshopper">open-sourced the tools</a>¬†used to develop NodeSchool.¬†</p>

<p>Using this toolchain makes¬†it simple to create similar exercise-led workshops for developers.</p>

<h2>OpenWhiskSchool?</h2>

<p>OpenWhisk has great documentation. The <a href="https://github.com/openwhisk/openwhisk/tree/master/docs">project repository includes Markdown files</a> for each feature of the platform.</p>

<p><strong><em>Would it be possible to use this material with the NodeSchool toolchain to create an interactive OpenWhisk workshop for developers?</em></strong></p>

<p>Developers would review the relevant documentation for a particular feature and use the tool to test their knowledge through an interactive exercise.</p>

<p>Each exercise would require them to build, deploy and configure a sample serverless function which used that platform feature.</p>

<p><em>After getting set up with the toolchain and reviewing other example projects, we started work on it‚Ä¶</em></p>

<h2>openwhisk-workshop</h2>

<p>üéâ <strong>Developers can now install the <a href="https://www.npmjs.com/package/openwhisk-workshop">workshop from NPM</a> as a global command.</strong> üéâ</p>

<p><code>
$ npm install -g openwhisk-workshop
</code></p>

<p><em>This tool needs the OpenWhisk command-line utility installed and authenticated against an instance of the platform. For more details on getting this environment setup, see the following documentation <a href="https://new-console.ng.bluemix.net/openwhisk/cli">here</a>.</em></p>

<p>Once the tool is installed, developers can open the application by running the following command.</p>

<p><code>
$ openwhisk-workshop
</code></p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/ow_workshop.png" alt="overview" /></p>

<p>The list of exercises will be displayed, along with current completion progress. Using the arrow keys (<kbd>‚Üë</kbd><kbd>‚Üì</kbd>) to navigate the menu, press <kbd>RETURN</kbd> to open an exercise.</p>

<p>On selecting an exercise, the problem challenge will be printed to the terminal.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/challenge.png" alt="exercise" /></p>

<p>Each exercise comes with a documentation page which explains the concepts behind the challenge. Use the following command to display the exercise documentation in the terminal.</p>

<p><code>
$ openwhisk-workshop more
</code></p>

<p>Once the developer has solved the challenge, they can verify their solution with the following command.</p>

<p><code>
$ openwhisk-workshop verify
</code></p>

<p>If their solution is correct, that task is marked as completed and the utility returns to the list of exercises.  Developers can continue working through the exercises until they have completed them all.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/verify.png" alt="verify" /></p>

<h2>feedback</h2>

<p>If you have problems with the workshop, please <a href="https://github.com/openwhisk/openwhisk-workshop/issues">raise an issue</a> in the repository.</p>

<p><em>Need more general help with OpenWhisk?</em></p>

<ul>
<li><a href="http://stackoverflow.com/questions/tagged/openwhisk">Stack Overflow #openwhisk</a>.</li>
<li><a href="https://developer.ibm.com/open/slackin/">Slack Group #openwhisk</a>.</li>
<li>Twitter <a href="https://twitter.com/openwhisk">@openwhisk</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenWhisk and Node-RED]]></title>
    <link href="http://jamesthom.as/blog/2016/09/26/node-red-and-openwhisk/"/>
    <updated>2016-09-26T15:16:00+01:00</updated>
    <id>http://jamesthom.as/blog/2016/09/26/node-red-and-openwhisk</id>
    <content type="html"><![CDATA[<p><a href="https://www.npmjs.com/package/node-red-node-openwhisk">Node-RED nodes for OpenWhisk</a> were initially released earlier this year. The nodes allowed users to manually invoke existing Actions and Triggers. This month, a <a href="https://github.com/node-red/node-red-node-openwhisk/releases/tag/0.3.0">new version of the package</a> has been released providing a huge improvement in the functionality‚Ä¶</p>

<h3>features</h3>

<ul>
<li>Users can now define new Actions using the flow editor UI, providing the source code through the inline node configuration panel.</li>
<li>Users can also modify existing Actions, with the live Action source being previewed in the node editor panel.</li>
<li>Triggers can be created and updated in the same way.</li>
<li>Both nodes allow users to view, define and modify default parameters for both Actions and Triggers.</li>
</ul>


<p><em>Deploying the flow will make the modifications to Actions and Triggers live for the configured OpenWhisk platform.</em></p>

<h3>example</h3>

<p>This video shows the updated nodes being used to define a new OpenWhisk Action, invoking it in response to a message from an inject node and then making modifications to the source code.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/NR_and_OW.gif"></p>

<h3>interested?</h3>

<p>Grab the <a href="https://www.npmjs.com/package/node-red-node-openwhisk">updated NPM package</a> to test the new features out today‚Ä¶</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Microservices Without Servers]]></title>
    <link href="http://jamesthom.as/blog/2016/09/08/microservices-without-servers/"/>
    <updated>2016-09-08T16:17:00+01:00</updated>
    <id>http://jamesthom.as/blog/2016/09/08/microservices-without-servers</id>
    <content type="html"><![CDATA[<p>‚Ä¶is the title of my presentation about building serverless applications using OpenWhisk.</p>

<script async class="speakerdeck-embed" data-id="387717983473473bb9eed49d50e6e279" data-ratio="1.77777777777778" src="http://jamesthom.as//speakerdeck.com/assets/embed.js"></script>


<h2>Abstract</h2>

<p><em>Servers are killing your productivity. Rather than building better software for your users, you end up constantly distracted by maintaining computers. Wasn't the "cloud" supposed to fix this? It sounded so promising until we realised it was just renting VMs in someone else's datacenter. We couldn't escape "servers". Until now...</em></p>

<p><em>In this session, developers will learn how to build microservices without servers, using modern ‚Äúserverless‚Äù cloud platforms. We‚Äôll look at common challenges (and solutions) to building applications using ‚Äúserverless‚Äù stacks. Exploring emerging ‚Äúserverless‚Äù design patterns will give developers the knowledge to build application architectures using these new platforms.</em></p>

<p><em>This session is aimed at software developers experienced in building traditional backend web applications, who want to learn how to build microservices without servers.</em></p>

<h2>Slides, Code, Videos</h2>

<p>Slides for the talk are available <a href="https://speakerdeck.com/jthomas/microservices-without-servers">here</a>.</p>

<p>There's a Github repository with resources <a href="https://github.com/jthomas/microservices_without_servers">from the talk</a>, including a <a href="https://github.com/jthomas/microservices_without_servers/blob/master/transcript.md">transcript</a>, <a href="https://github.com/jthomas/microservices_without_servers/blob/master/code">code demos</a> and <a href="https://www.youtube.com/playlist?list=PL0UyhC0D6KABYPvGroXcIeE-4x_yEbdB4">videos</a>.</p>

<p>If you have questions or issues, raise an issue in the repository or send me a <a href="https://twitter.com/thomasj">tweet</a>.</p>

<h2>Conference Sessions</h2>

<p>This talk was <a href="http://www.jday.com.ua/#nav-schedule">first delivered</a> at <a href="https://http://www.jday.com.ua/">JDayLviv</a> earlier this month. The session was recorded so the video should surface online soon. I'll be repeating the talk at <a href="https://belgrade.voxxeddays.com/talk/145/">VoxxedDays Belgrade</a> and <a href="http://javaday.org.ua/kyiv/#speakers">JavaDay Kiev</a> in September and October.</p>
]]></content>
  </entry>
  
</feed>
