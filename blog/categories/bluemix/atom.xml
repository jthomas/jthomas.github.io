<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: bluemix | James Thomas]]></title>
  <link href="http://jamesthom.as/blog/categories/bluemix/atom.xml" rel="self"/>
  <link href="http://jamesthom.as/"/>
  <updated>2016-01-04T15:29:55+00:00</updated>
  <id>http://jamesthom.as/</id>
  <author>
    <name><![CDATA[James Thomas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Updated IBM Watson Nodes for Node-RED]]></title>
    <link href="http://jamesthom.as/blog/2016/01/04/updated-ibm-watson-nodes/"/>
    <updated>2016-01-04T15:45:00+00:00</updated>
    <id>http://jamesthom.as/blog/2016/01/04/updated-ibm-watson-nodes</id>
    <content type="html"><![CDATA[<p>{% img /images/node-red-updates.png %}</p>

<p>Earlier this year, I made a <a href="http://jamesthom.as/blog/2015/04/22/ibm-watson-nodes-for-nodered/">major upate</a> to the Node-RED nodes for the IBM
Watson services available through IBM Bluemix. Since then, the IBM Watson team
has been <a href="https://developer.ibm.com/watson/blog">busy</a>, with lots of changes to APIs. I've recently been working through
these changes, updating the nodes, to ensure they work against the latest APIs.</p>

<p><strong>Updates to these nodes have now been finished and are available through the
<a href="https://console.ng.bluemix.net/catalog/starters/node-red-starter/">boilerplate</a> on IBM Bluemix or by installing the <a href="https://github.com/node-red/node-red-bluemix-nodes">IBM Bluemix Nodes</a> package
locally.</strong></p>

<p>If you have an existing Node-RED instance running in IBM Bluemix, please review
the <a href="https://www.ng.bluemix.net/docs/#starters/Node-RED/nodered.html#nodered">documentation</a> for upgrade instructions.</p>

<p>If you encounter any issues, please raise a <a href="https://github.com/node-red/node-red-bluemix-nodes/issues">issue on Github</a>.</p>

<p><em>For full details on the changes are available in the <a href="https://github.com/node-red/node-red-bluemix-nodes/pull/30">pull request</a>.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Updated Node-RED IBM Watson Nodes]]></title>
    <link href="http://jamesthom.as/blog/2016/01/04/node-red-bluemix-nodes-update/"/>
    <updated>2016-01-04T15:45:00+00:00</updated>
    <id>http://jamesthom.as/blog/2016/01/04/node-red-bluemix-nodes-update</id>
    <content type="html"><![CDATA[<p>{% img /images/node-red-updates.png %}</p>

<p>Earlier this year, I made a <a href="http://jamesthom.as/blog/2015/04/22/ibm-watson-nodes-for-nodered/">major upate</a> to the Node-RED nodes for the IBM
Watson services available through IBM Bluemix. Since then, the IBM Watson team
has been <a href="https://developer.ibm.com/watson/blog">busy</a>, with lots of changes to APIs. I've recently been working through
these changes, updating the nodes, to ensure they work against the latest APIs.</p>

<p><strong>Updates to these nodes have now been finished and are available through the
<a href="https://console.ng.bluemix.net/catalog/starters/node-red-starter/">boilerplate</a> on IBM Bluemix or by installing the <a href="https://github.com/node-red/node-red-bluemix-nodes">IBM Bluemix Nodes</a> package
locally.</strong></p>

<p>If you have an existing Node-RED instance running in IBM Bluemix, please review
the <a href="https://www.ng.bluemix.net/docs/#starters/Node-RED/nodered.html#nodered">documentation</a> for upgrade instructions.</p>

<p>If you encounter any issues, please raise a <a href="https://github.com/node-red/node-red-bluemix-nodes/issues">issue on Github</a>.</p>

<p><em>For full details on the changes are available in the <a href="https://github.com/node-red/node-red-bluemix-nodes/pull/30">pull request</a>.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.js v4 in Cloud Foundry]]></title>
    <link href="http://jamesthom.as/blog/2015/09/18/node-dot-js-v4-in-cloud-foundry/"/>
    <updated>2015-09-18T17:33:00+01:00</updated>
    <id>http://jamesthom.as/blog/2015/09/18/node-dot-js-v4-in-cloud-foundry</id>
    <content type="html"><![CDATA[<p>Last week, Node.js <a href="https://nodejs.org/en/blog/release/v4.0.0/">released the latest version</a>
of their project, v4.0.0. This release, representing the convergence of io.js with the original Node.js
project, came with lots of exciting features like <a href="http://apmblog.dynatrace.com/2015/09/05/all-you-need-to-know-about-node-js-4-0/">improved ES6 support</a>.</p>

<p>Cloud Foundry already <a href="https://docs.cloudfoundry.org/buildpacks/node/node-tips.html">supports multiple versions</a> of the Node.js runtime.
Developers select the desired runtime version using a parameter in their
application's <a href="http://browsenpm.org/package.json">package descriptor</a>.</p>

<p><em>So, we just update package.json to include "4.0.0" and re-deploy our application?</em></p>

<p>Not yet.</p>

<p>There is an <a href="https://github.com/nodejs/node/issues/2783">unresolved technical issue</a>
delaying the <a href="https://www.pivotaltracker.com/n/projects/1042066/stories/102941608">release</a> of "official"
Node.js v4 support for the platform. 😿</p>

<p><em>Can we add support ourselves?</em></p>

<p><strong>Yes!</strong></p>

<p>To do this, we need to explore how Cloud Foundry configures the runtime
environment for applications.</p>

<h2>Buildpacks</h2>

<p>Rather than hardcoding supported runtimes and frameworks into the platform,
Cloud Foundry borrowed the <a href="https://docs.cloudfoundry.org/buildpacks/"><em>buildpack model</em></a> from Heroku. Buildpacks are a
<a href="https://docs.cloudfoundry.org/buildpacks/custom.html#custom-buildpacks">set of scripts</a>, run by the platform during deployment, to configure the runtime
environment.</p>

<p>Users can set an explicit buildpack for an application, <a href="https://docs.cloudfoundry.org/devguide/deploy-apps/manifest.html#buildpack">using the manifest</a>, or let
the platform decide. Buildpacks for <a href="https://docs.cloudfoundry.org/buildpacks/">common runtimes</a> are pre-installed with the platform.
Buildpacks set through the manifest can point to external URLs, allowing users to create
new buildpacks supporting custom runtimes.</p>

<p>Each buildpack must contain the following files as executable scripts.</p>

<ul>
<li><strong>bin/detect</strong> - <em>determine whether a buildpack is suitable for an application.</em></li>
<li><strong>bin/compile</strong> - <em>install and configure the runtime environment on the DEA.</em></li>
<li><strong>bin/release</strong> - <em>provide metadata with information on executing application.</em></li>
</ul>


<p>Full details on existing buildpacks for the platform are available <a href="https://github.com/cloudfoundry-community/cf-docs-contrib/wiki/Buildpacks">here</a>.</p>

<p>Node.js is supported as an "official" buildpack by the platform. This will be
the one we will modify to add support for the latest version of the runtime.</p>

<h2>Node.js Buildpack </h2>

<p><a href="https://github.com/cloudfoundry/nodejs-buildpack">This</a> is the Node.js
buildpack for Cloud Foundry. Applications using this buildpack can select the
version of Node.js to install using the engine parameter in the package
descriptor.</p>

<p>Looking at the <a href="https://github.com/cloudfoundry/nodejs-buildpack/blob/master/bin/compile"><em>bin/compile</em></a>
script will show us how the Node.js runtime is installed during deployment.</p>

<p>This <a href="https://github.com/cloudfoundry/nodejs-buildpack/blob/master/bin/compile#L66-L88">snippet</a> handles
accessing the Node.js version configured, using the node.engine parameter from package.json, before calling
<em>install_nodejs</em> to install the correct runtime package.</p>

<pre>
install_bins() {
  local node_engine=$(read_json "$BUILD_DIR/package.json" ".engines.node")
  local npm_engine=$(read_json "$BUILD_DIR/package.json" ".engines.npm")

  echo "engines.node (package.json):  ${node_engine:-unspecified}"
  echo "engines.npm (package.json):   ${npm_engine:-unspecified (use default)}"
  echo ""

  warn_node_engine "$node_engine"
  install_nodejs "$node_engine" "$BUILD_DIR/.heroku/node"
  install_npm "$npm_engine" "$BUILD_DIR/.heroku/node"
  warn_old_npm
}
</pre>


<p>Searching through the buildpack for this function, it's in the
<a href="https://github.com/cloudfoundry/nodejs-buildpack/blob/master/lib/binaries.sh">lib/binaries.sh</a>
file.  Looking at the <a href="https://github.com/heroku/heroku-buildpack-nodejs/blob/master/lib/binaries.sh#L10-L25">function code</a>, it translates the version number into a
URL pointing to an archive with the pre-compiled Node.js binary. This archive
file is downloaded, extracted and installed into the runtime environment.</p>

<p>Translating Node.js version identifiers into archive URLs uses a special file
in the buildpack, <a href="https://github.com/cloudfoundry/nodejs-buildpack/blob/master/manifest.yml">manifest.yml</a>. This file maps every supported version to a
pre-built binary location.</p>

<p>Looking at <a href="https://github.com/cloudfoundry/nodejs-buildpack/commit/8536a85cd69c867dc797c9586839a1373da4fd9d">previous commits</a> to the Node.js buildpack, adding support for additional
versions of Node.js simply requires updating this file with the extra version
identifier and archive URL.</p>

<p>Until the Cloud Foundry team updates the buildpack to support Node.js v4, they won't
provide an external archive containing the pre-built runtime environment.</p>

<p><em>Where can we find a suitable build of the Node.js binary?</em></p>

<h2>Node.js Runtime Binaries </h2>

<p>Cloud Foundry borrowed the <strong>buildpack</strong> concept from <a href="https://devcenter.heroku.com/articles/buildpacks">Heroku</a> and still
maintains backwards compatibility with their platform. Heroku buildpacks will
work with Cloud Foundry applications. The Node.js buildpack for Cloud Foundry
is actually still a fork of <a href="https://github.com/heroku/heroku-buildpack-nodejs">Heroku's</a>.</p>

<p>Looking back through the original buildpack source, this URL template is used to translate
Node.js versions to archive URLs being built by Heroku.</p>

<p><em>http://s3pository.heroku.com/node/v$version/node-v$version-$os-$cpu.tar.gz</em></p>

<p>Combining the correct version identifier and platform parameters with this
template gave the following location for a potential build of the Node.js v4
runtime.</p>

<p><a href="">http://s3pository.heroku.com/node/v4.0.0/node-v4.0.0-linux-x64.tar.gz</a></p>

<p>Running curl against the location successfully downloaded the Node.js v4 binary archive!</p>

<h2>Custom v4 Buildpack</h2>

<p>Forking the Cloud Foundry Node.js buildpack on Github, we can update the
<a href="https://github.com/jthomas/nodejs-v4-buildpack/blob/master/manifest.yml#L57-L62">manifest.yml</a> with the Node.js v4 identifier pointing to the Heroku runtime
archive. This <a href="https://github.com/jthomas/nodejs-v4-buildpack">external Git repository</a> will be used as the buildpack identifier
in the application manfest.</p>

<h2>Deploying with v4</h2>

<p>Having updated our application manifest with the custom buildpack location and
set the updated node version flag, re-deploying our application will start it
running on Node.js v4.</p>

<p>``` sh
[20:02:29 ~]$ cf app sample-demo-app
Showing health and status for app sample-demo-app in org james.thomas@uk.ibm.com / space dev as james.thomas@uk.ibm.com...
OK</p>

<p>requested state: started
instances: 1/1
usage: 256M x 1 instances
urls: sample-demo-app.mybluemix.net
last uploaded: Fri Sep 18 18:33:56 UTC 2015
stack: lucid64
buildpack: SDK for Node.js(TM) (node.js-4.0.0)</p>

<pre><code> state     since                    cpu    memory          disk        details
</code></pre>

<h1>0   running   2015-09-18 07:35:01 PM   0.0%   65.3M of 256M   59M of 1G</h1>

<p>[20:03:13 ~]$
```</p>

<p>Looking at the logs from the deployment we can see the latest Node.js
runtime has been downloaded and installed within our runtime environment.</p>

<h2>Conclusion</h2>

<p>Buildpacks are a brilliant feature of Cloud Foundry.</p>

<p>Understanding how buildpacks are structured and used by the platform means we
can start customising existing buildpacks and even start creating our own.</p>

<p><strong>If you want to run Node.js applications using v4 on Cloud Foundry today, you
can use the <a href="https://github.com/jthomas/nodejs-v4-buildpack">following buildpack</a>
created using the instructions above.</strong></p>

<p>Cloud Foundry is currently adding support for the version to
the official buildpack, follow their progress <a href="https://www.pivotaltracker.com/n/projects/1042066/stories/102941608">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Location-Based Cloud Foundry Applications using Nginx and Docker]]></title>
    <link href="http://jamesthom.as/blog/2015/09/11/location-based-cloud-foundry-applications-with-nginx-and-docker/"/>
    <updated>2015-09-11T10:24:00+01:00</updated>
    <id>http://jamesthom.as/blog/2015/09/11/location-based-cloud-foundry-applications-with-nginx-and-docker</id>
    <content type="html"><![CDATA[<p>{% img /images/geo_web_view.png %}</p>

<p>Routing application traffic based upon the geographic location of incoming requests can
be used for a number of scenarios...</p>

<ul>
<li>Restricting access to your application outside defined geographic regions.</li>
<li>Load-balancing traffic to the closest region for improved performance.</li>
<li>Providing custom applications for different countries.</li>
</ul>


<p>IBM Bluemix allows deploying applications to different geographic regions through
hosting instances of the <a href="https://www.cloudfoundry.org/">Cloud Foundry</a> platform in <a href="https://www.ibm.com/developerworks/community/blogs/enablingwithbluemix/entry/regions_in_bluemix?lang=en">multiple locations</a>.</p>

<p>Cloud Foundry supports <a href="https://docs.cloudfoundry.org/devguide/deploy-apps/domains-routes.html">simple HTTP routing rules</a> for deployed applications.
Organisations can register domains and routes for applications. Routes can be
bound to one or more deployed applications. Incoming HTTP traffic is
load-balanced, using the <a href="https://en.wikipedia.org/wiki/Round-robin_scheduling">Round-Robin</a> policy, between the application instances bound to a route.</p>

<p><em>However, the platform does not currently support traffic routing based upon the
geographic location of incoming requests or sharing domains and routes between regions.</em></p>

<p><strong>So, say we want to deploy custom versions of an application to different regions and
automatically forward users to the correct version based upon their location. How can we
achieve this?</strong></p>

<p>Let's find out...</p>

<h2>Deploying Application To Different Regions</h2>

<p>IBM Bluemix currently provides Cloud Foundry in <a href="https://www.ng.bluemix.net/docs/overview/overview.html#ov_intro">two regions</a> for deploying applications.</p>

<ul>
<li><strong>US South</strong> (<em>api.ng.bluemix.net</em>)</li>
<li><strong>Europe</strong> (<em>api.eu-gb.bluemix.net</em>)</li>
</ul>


<p>Moving between regions is as simple as providing the different region endpoint during the
authentication command.</p>

<p>``` sh
[16:25:47 ~]$ cf login -a api.ng.bluemix.net -u james.thomas@uk.ibm.com -s dev
API endpoint: api.ng.bluemix.net</p>

<p>Password>
Authenticating...
OK</p>

<p>Targeted org james.thomas@uk.ibm.com</p>

<p>Targeted space dev</p>

<p>API endpoint:   https://api.ng.bluemix.net (API version: 2.27.0)
User:           james.thomas@uk.ibm.com
Org:            james.thomas@uk.ibm.com
Space:          dev
[16:26:44 ~]$
```</p>

<p>We're now authenticated against the US South region.</p>

<p>Let's start by deploying our sample application, which displays a web
page showing the application URL, to this region.</p>

<p>``` sh
[16:44:24 ~/code/sample]$ cf api
API endpoint: https://api.ng.bluemix.net (API version: 2.27.0)
[16:44:32 ~/code/sample]$ cf push sample-demo-app
Using manifest file /Users/james/code/sample/manifest.yml</p>

<p>Updating app sample-demo-app in org james.thomas@uk.ibm.com / space dev as james.thomas@uk.ibm.com...
OK</p>

<p>...</p>

<p>Showing health and status for app sample-demo-app in org james.thomas@uk.ibm.com / space dev as james.thomas@uk.ibm.com...
OK</p>

<p>requested state: started
instances: 1/1
usage: 256M x 1 instances
urls: sample-demo-app.mybluemix.net
last uploaded: Fri Sep 11 15:45:04 UTC 2015
stack: lucid64
buildpack: SDK for Node.js(TM) (node.js-4.0.0)</p>

<pre><code> state     since                    cpu    memory          disk        details
</code></pre>

<h1>0   running   2015-09-11 04:46:00 PM   0.0%   67.1M of 256M   59M of 1G</h1>

<p>[16:45:14 ~/code/sample]$
```</p>

<p>Once that has finished, we can move over to the European region and deploy our application there.</p>

<p>``` sh
[16:52:33 ~/code/sample]$ cf login -a api.eu-gb.bluemix.net -u james.thomas@uk.ibm.com -s dev
[16:52:58 ~/code/sample]$ cf push sample-demo-app
Using manifest file /Users/james/code/sample/manifest.yml</p>

<p>Updating app sample-demo-app in org james.thomas@uk.ibm.com / space dev as james.thomas@uk.ibm.com...
OK</p>

<p>...</p>

<p>Showing health and status for app sample-demo-app in org james.thomas@uk.ibm.com / space dev as james.thomas@uk.ibm.com...
OK</p>

<p>requested state: started
instances: 1/1
usage: 256M x 1 instances
urls: sample-demo-app.eu-gb.mybluemix.net
last uploaded: Fri Sep 11 15:53:31 UTC 2015
stack: lucid64
buildpack: SDK for Node.js(TM) (node.js-4.0.0)</p>

<pre><code> state     since                    cpu    memory          disk        details
</code></pre>

<h1>0   running   2015-09-11 04:54:17 PM   0.0%   67.4M of 256M   59M of 1G</h1>

<p>[16:54:25 ~/code/bluemix/sample]$
```</p>

<p>With the second deployment completed, there are now instances of the same application running in separate regions.</p>

<p>Each instance is available through a separate URL.</p>

<ul>
<li><a href="http://sample-demo-app.mybluemix.net">http://sample-demo-app.mybluemix.net</a></li>
<li><a href="http://sample-demo-app.eu-gb.mybluemix.net">http://sample-demo-app.eu-gb.mybluemix.net</a></li>
</ul>


<p>Now we need to set up traffic forwarding from the relevant locations to the correct region.</p>

<h2>Reverse Proxy with Region Traffic Forwarding</h2>

<p>Due to the platform not supporting multi-region traffic routing, we
need to set up a custom reverse proxy. This server will receive
requests from our external application domain and transparently forward
them onto the correct region application.</p>

<p>{% img /images/reverse_proxy.png %}</p>

<p>We're going to use <a href="http://nginx.org/">Nginx</a>.</p>

<p>{% blockquote Nginx http://wiki.nginx.org/Main %}</p>

<p>Nginx (pronounced engine-x) is a free, open-source, high-performance HTTP server and reverse proxy, as well as an IMAP/POP3 proxy server</p>

<p>{% endblockquote %}</p>

<p>Nginx comes with a <a href="http://nginx.org/en/docs/http/ngx_http_geoip_module.html">module</a> for looking up locations associated with IP
address using the <a href="http://dev.maxmind.com/geoip/">MaxMind GeoIP library</a>. The module can
resolve incoming request addresses into continents, countries and even cities. Using the variables defined by the module, we
can write traffic forwarding rules to send requests to the correct region.</p>

<h2>Nginx Configuration</h2>

<p>Nginx defines two configuration directives, <em>geoip_country</em> and <em>geoip_city</em>, to
specify locations for the MaxMind GeoIP database files.</p>

<pre>
http { 
    ...
    geoip_country /usr/share/GeoIP/GeoIP.dat;
    geoip_city /etc/nginx/geoip/GeoLiteCity.dat;
    ...
}
</pre>


<p>When configured, Nginx will expose a series of variables for each request with
geographical information.</p>

<ul>
<li><strong>$geoip_country_code</strong> - <em>two-letter country code, for example, “RU”, “US”.</em></li>
<li><strong>$geoip_country_name</strong> - <em>country name, for example, “Russian Federation”, “United States”.</em></li>
<li><strong>$geoip_city_continent_code</strong> - <em>two-letter continent code, for example, “EU”, “NA”.</em></li>
<li><strong>$geoip_city</strong> - <em>city name, for example, “Moscow”, “Washington”.</em></li>
</ul>


<p>Starting with the <a href="http://wiki.nginx.org/FullExample">default nginx configuration</a>,
there are only a few modifications needed to set up a reverse proxy based upon
location.</p>

<p>For each request, we check the <em>$geoip_city_continent_code</em> against our list of
regions. If the request is valid, setting the <em>proxy_pass</em> directive forwards
the request onto the correct region. We also overwrite the <em>Host:</em> HTTP
header with the region URL. IBM Bluemix uses this header to internally route
incoming requests to the correct application host.</p>

<p>Requests coming from outside these locations will be sent to a custom error
page.</p>

<p><em>Due to a <a href="https://www.ng.bluemix.net/docs/containers/container_troubleshoot.html">known issue</a>
with IBM Containers, we must use IP addresses rather than the host names with the proxy_pass directive.</em></p>

<p>Here is the full configuration for the <em>enabled-site/default</em> file.</p>

<pre>
server {
  listen 80 default_server;
  listen [::]:80 default_server ipv6only=on;

  root /usr/share/nginx/html;
  index index.html index.htm;
  error_page 404 /404.html;

# Make site accessible from http://localhost/
  server_name localhost;

  location = /404.html {
    internal;
  }

  location / {
    set $host_header "unknown";

    if ($geoip_city_continent_code = "EU") { 
      proxy_pass http://5.10.124.141;
      set $host_header "sample-demo-app.eu-gb.mybluemix.net";
    }

    if ($geoip_city_continent_code = "NA") { 
      proxy_pass http://75.126.81.66;
      set $host_header "sample-demo-app.mybluemix.net";
    }

    if ($host_header = "unknown") {
      return 404;
    }

    proxy_set_header Host $host_header;
  }
}
</pre>


<p>With the reverse proxy server configured, we need to provision a new
production server, install Linux and Nginx, configure networking, security updates
and backup services...</p>

<p><em>...or we can use Docker.</em></p>

<h2>Running Nginx using Docker</h2>

<p>There are <a href="https://hub.docker.com/search/?q=nginx&amp;page=1&amp;isAutomated=0&amp;isOfficial=0&amp;starCount=0&amp;pullCount=0">thousands</a>
of repositories on Docker Hub providing Nginx, including
the official image. Unfortunately, the <a href="http://wiki.nginx.org/FullExample">official image</a> provides a version of Nginx
that is not built with the <em>geo_ip</em> module.</p>

<p>Ubuntu's default package repository for Nginx does provide a build including
the <em>geo_ip</em> module. By modifying the Dockerfile for the official image, we can
build a new image from Ubuntu with the required version of Nginx and include
our custom configuration files.</p>

<pre>
FROM ubuntu
RUN apt-get -y install nginx

# copy custom configuration
COPY nginx.conf /etc/nginx/nginx.conf
COPY default /etc/nginx/sites-available/
COPY geoip /etc/nginx/geoip
COPY 404.html /usr/share/nginx/html/

# forward request and error logs to docker log collector
RUN ln -sf /dev/stdout /var/log/nginx/access.log
RUN ln -sf /dev/stderr /var/log/nginx/error.log

# expose HTTP and HTTP ports
EXPOSE 80 443

CMD ["nginx", "-g", "daemon off;"]
</pre>


<p>Building and running this container locally, we can test that Nginx is configured correctly. The repository containing the Dockerfile
and build artificats is located <a href="https://github.com/jthomas/geo_ip">here</a>.</p>

<p><code>sh
[16:58:40 ~/code/final]$ docker build -t geo_ip .
Sending build context to Docker daemon 15.88 MB
Step 0 : FROM ubuntu
 ---&gt; 91e54dfb1179
...
Step 9 : CMD nginx -g daemon off;
 ---&gt; Using cache
 ---&gt; 7bb6dbaafe3e
Successfully built 7bb6dbaafe3e
[16:58:50 ~/code/final]$ docker run -Pti geo_ip
</code>
<em>With the custom image ready, we just need to deploy it somewhere...</em></p>

<h2>Running Nginx on IBM Containers</h2>

<p>IBM Bluemix supports deploying Docker containers alongside Cloud Foundry
applications, allowing us to use the same cloud platform for running our custom
region applications as providing the reverse proxy</p>

<p>Pushing pre-built images to the IBM Containers service is really as simple as creating a new tag and typing <em>docker push</em>.</p>

<p><em>Please read and follow the <a href="https://www.ng.bluemix.net/docs/containers/container_cli_ov.html">documentation</a>
about installing the command-line container management tools and authenticating
with the remote service before attempting the commands below.</em></p>

<p><code>sh
[14:10:52 ~]$ docker tag geo_ip registry.ng.bluemix.net/jthomas/geo_ip
[14:10:59 ~]$ docker images
REPOSITORY                               TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
geo_ip                                   latest              7bb6dbaafe3e        3 days ago          222.3 MB
registry.ng.bluemix.net/jthomas/geo_ip   latest              7bb6dbaafe3e        3 days ago          222.3 MB
[14:11:07 ~]$ cf ic login
** Retrieving client certificates from IBM Containers
** Storing client certificates in /Users/james/.ice/certs
Successfully retrieved client certificates
** Authenticating with registry at registry.eu-gb.bluemix.net
Successfully authenticated with registry
[14:24:25 ~]$ docker push registry.ng.bluemix.net/jthomas/geo_ip
The push refers to a repository [registry.ng.bluemix.net/jthomas/geo_ip] (len: 1)
Sending image list
Pushing repository registry.ng.bluemix.net/jthomas/geo_ip (1 tags)
...
Pushing tag for rev [7bb6dbaafe3e] on {https://registry.ng.bluemix.net/v1/repositories/jthomas/geo_ip/tags/latest}
[14:25:39 ~]$ cf ic images
REPOSITORY                                        TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
registry.ng.bluemix.net/jthomas/geo_ip            latest              7b1865be-778        About a minute ago   0 B
registry.ng.bluemix.net/ibmliberty                latest              2209a9732f35        3 weeks ago          263.6 MB
registry.ng.bluemix.net/ibmnode                   latest              8f962f6afc9a        3 weeks ago          178.9 MB
registry.ng.bluemix.net/ibm-mobilefirst-starter   latest              97513e56aaa7        3 weeks ago          464.9 MB
[14:26:43 ~]$
</code></p>

<p>We can now use the IBM Bluemix dashboard to start a new container from our custom image,
binding a public IP address and exposing ports.</p>

<p>{% img /images/deploy_container.png %}</p>

<p>Once the container starts, accessing the bound IP address shows the
web page coming back with the region-specific application route.</p>

<p>{% img /images/container_ip_address.png %}</p>

<p>Using DNS <a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types#A">A records</a>, we can now
map our external URL to the IP address of the container. Users visiting this
URL will be sent to the reverse proxy server which will then forward the
request onto the correct region application.</p>

<h2>Testing it all out...</h2>

<p>Testing out the forwarding rules requires us to send HTTP requests from multiple regions.
<a href="http://geowebview.com">GeoWebView</a> will run web browsers located in different geographies and show you the rendered page output.</p>

<p>Running the tool with our application's <a href="http://geo_ip.jamesthom.as">web address</a>, shows the following rendered page images.</p>

<p>{% img /images/geo_web_view.png %}</p>

<p>We can see the browsers from the United States and Europe are sent to the correct region. The browser from South Africa is shown the custom error page.</p>

<p><em>Using Nginx we've configured a reverse proxy to route users, based upon their location, to applications running in different IBM Bluemix regions. We're hosting
the service on the same platform as our applications, using Docker. Most importantly, the whole process is transparent to the user, they aren't forced to visit
country-specific URLs.</em></p>

<p><strong>Success!</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[running one-off tasks in cloud foundry]]></title>
    <link href="http://jamesthom.as/blog/2015/09/01/running-one-off-tasks-in-cloud-foundry/"/>
    <updated>2015-09-01T16:07:00+01:00</updated>
    <id>http://jamesthom.as/blog/2015/09/01/running-one-off-tasks-in-cloud-foundry</id>
    <content type="html"><![CDATA[<p>Whether making changes to a database schema, bulk importing data to initialise
a database or setting up a connected service, there are often administrative
tasks that needed to be carried out for an application to run correctly.</p>

<p>These tasks usually need finishing before starting the application and should not be
executed more than once.</p>

<p>Previously, the <a href="https://github.com/cloudfoundry/cli">CF CLI</a> provided commands, <em>tunnel</em> and <em>console</em>, to help running
one-off tasks manually. These commands were
<a href="http://stackoverflow.com/questions/32332319/exposing-ports-502-and-1002-from-nodejs-using-bluemix/32333386#32333386">deprecated</a>
with the upgrade from <em>v5</em> to <em>v6</em>
to discourage <a href="http://martinfowler.com/bliki/SnowflakeServer.html">snowflake environments</a>.</p>

<p>It is still possible, with a bit of hacking, to run one-off tasks manually from the application
container.</p>

<p>A better way is to describe <em>tasks as code</em> and run them automatically during normal
deployments. This results in applications that can be recreated without
manual intervention.</p>

<p>We'll look at both options before introducing a new library, <a href="https://github.com/IBM-Bluemix/oneoff">oneoff</a>, that automates
running administration tasks for Node.js applications.</p>

<h2>Running Tasks Manually</h2>

<h2>Local Environment</h2>

<p>Rather than running administrative tasks from the application console, we can
run them from a local development environment by remotely connecting to
the bound services.</p>

<p>This will be dependent on the provisioned services allowing remote access.
Many "built-in" platform services, e.g. MySQL, Redis, do not allow this.</p>

<p>Third-party services generally do.</p>

<p>Using the <em>cf env</em> command we can list service credentials for an application.
These authentication details can often be used locally by connecting through a client
library running in a local development environment.</p>

<p>For example, to access a provisioned Cloudant instance locally, we can grab the credentials
and use with a Node.js client library.</p>

<p>``` sh
[15:48:22 ~/code/sample]$ cf env sample-demo-app
Getting env variables for app sample-demo-app in org james.thomas@uk.ibm.com / space dev as james.thomas@uk.ibm.com...
OK</p>

<p>System-Provided:
{
 "VCAP_SERVICES": {
  "cloudantNoSQLDB": [
   {</p>

<pre><code>"credentials": {
 "host": "1234-bluemix.cloudant.com",
 "password": "sample_password",
 "port": 443,
 "url": "https://1234-bluemix:sample_password@1234-bluemix.cloudant.com",
 "username": "1234-bluemix"
}
</code></pre>

<p>....</p>

<p>[15:48:22 ~/code/sample]$ cat connect.js
var Cloudant = require('cloudant');</p>

<p>var me = '1234-bluemix';
var password = 'sample_password';</p>

<p>// Initialize the library with my account.
var cloudant = Cloudant({account:me, password:password});</p>

<p>cloudant.db.list(function(err, allDbs) {
  console.log('All my databases: %s', allDbs.join(', '))
  // Run administrative tasks
});
[15:48:22 ~/code/sample]$ node connect.js
All my databases: example_db, jasons_stuff, scores
```</p>

<h2>Remote Environment</h2>

<p>When provisioned services don't allow external access, the
<a href="https://github.com/cloudfoundry-community/cf-ssh">cf-ssh</a> project creates SSH
access to application containers running within Cloud Foundry.</p>

<p><strong>How does this work?!</strong></p>

<p>{% blockquote Dr. Nic https://blog.starkandwayne.com/2014/10/28/how-does-cf-ssh-get-you-an-ssh-session-into-cloud-foundry/ %}
cf-ssh deploys a new Cloud Foundry application, containing the same bits as your target application, with the same bound services.
This new application's container does not start your web application as per normal. Instead, it starts an outbound reverse SSH tunnel to a public proxy.
The local cf-ssh client then launches an interactive ssh connect to the public proxy, which tunnels through to the application container.
{% endblockquote %}</p>

<p>See the explanation <a href="https://blog.starkandwayne.com/2014/10/28/how-does-cf-ssh-get-you-an-ssh-session-into-cloud-foundry/">here</a> for full details.</p>

<p>This approach will let you connect to services from within the Cloud Foundry platform environment.</p>

<p>This video from <a href="https://starkandwayne.com/">Stark &amp; Wayne's</a> <a href="http://drnicwilliams.com/">Dr. Nic</a> shows the command in action...</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/eWJCfAa1_x8" frameborder="0" allowfullscreen></iframe>


<h2>IBM Bluemix Console (Java and Node.js)</h2>

<p><em>This technique is only for the IBM Bluemix platform.</em></p>

<p>If you are deploying Node.js and Java applications on <a href="https://bluemix.net">IBM Bluemix</a>, the platform provides
the following tools to assist with <a href="https://www.ng.bluemix.net/docs/#manageapps/app_management.html#appmanagement">application management</a>.</p>

<ul>
<li><em>proxy</em>: Minimal application management that serves as a proxy between your application and Bluemix.</li>
<li><em>devconsole</em>: Enables the development console utility.</li>
<li><em>shell</em>: Enables a web-based shell.</li>
<li><em>trace</em>: (Node.js only) Dynamically set trace levels if your application is using log4js, ibmbluemix, or bunyan logging modules.</li>
<li><em>inspector</em>: (Node.js only) Enables node inspector debugger.</li>
<li><em>debug</em>: (Liberty only) Enables clients to establish a remote debugging session with the application.</li>
<li><em>jmx</em>: (Liberty only) Enables the JMX REST Connector to allow connections from remote JMX clients</li>
</ul>


<p>The tools are enabled by setting the environment variable (<em>BLUEMIX_APP_MGMT_ENABLE</em>) with the
desired utilities.</p>

<p><code>sh
$ cf set-env myApp BLUEMIX_APP_MGMT_ENABLE devconsole+shell+trace
</code></p>

<p>Applications must be restarted for the changes to take effect.</p>

<p>If we enable the <em>shell</em> utility, the following web-based console will be available at https://your-app-name.mybluemix.net/bluemix-debug/shell.</p>

<p>{% img https://developer.ibm.com/bluemix/wp-content/uploads/sites/20/2015/06/shell.jpg %}</p>

<h2>Cloud Foundry Diego Runtime</h2>

<p><a href="http://www.activestate.com/blog/2014/09/cloud-foundry-diego-explained-onsi-fakhouri">Diego</a> is the next-generation
runtime that will power upcoming versions of Cloud Foundry. Diego will provide many benefits
over the existing runtime, e.g. Docker support, including enabling SSH access to containers without the workarounds needed above.</p>

<p><strong>Yay!</strong></p>

<p>Follow the instructions <a href="https://github.com/cloudfoundry-incubator/diego-design-notes/blob/master/ssh-access-and-policy.md">here</a>
for details on SSH access to applications running on the new runtime.</p>

<p><em>Access to this feature will be dependent on your Cloud Foundry provider migrating to the new runtime.</em></p>

<h2>Running Tasks Automatically </h2>

<p>Manually running one-off administrative tasks for Cloud Foundry applications is a <a href="http://martinfowler.com/bliki/SnowflakeServer.html">bad idea</a>.</p>

<p>It affects your ability to do continuous delivery and encourages snowflake environments.</p>

<p>Alternatively, defining <em>tasks as code</em> means they can run automatically during normal deployments.
No more manual steps are required to deploy applications.</p>

<p>There are <a href="http://flywaydb.org/">many</a> <a href="https://github.com/ruby/rake">different</a> <a href="https://github.com/seomoz/shovel">libraries</a>
for <a href="https://phinx.org/">every</a> <a href="https://github.com/mattes/migrate">language</a> to help you programmatically define, manage and run tasks.</p>

<p>With <em>tasks defined as code</em>, you need to configure your <a href="https://docs.cloudfoundry.org/devguide/deploy-apps/manifest.html">application manifest</a>
to run these automatically during deployments.</p>

<p>Cloud Foundry uses the <a href="https://docs.cloudfoundry.org/devguide/deploy-apps/manifest.html#start-commands"><em>command</em> parameter</a>,
set in the manifest or through the
command-line, to allow applications to specify a custom start command. We can
use this parameter to execute the task library command during deployment.</p>

<p>The Cloud Foundry documentation also details these approaches, with slightly different
implementations <a href="https://docs.cloudfoundry.org/devguide/services/migrate-db.html">here</a>
and specifically for Ruby developers <a href="https://docs.cloudfoundry.org/buildpacks/ruby/ruby-tips.html#rake">here</a>.</p>

<h2>Temporary Task Deploy</h2>

<p>For applications which only need occasional administrative tasks, it's often
easier to push a temporary deploy with a custom start command. This deploy
runs your tasks without then starting your application. Once the tasks have
completed, redeploy your application normally, destroying the task instance.</p>

<p>The following command will deploy a temporary instance for this purpose:</p>

<p><code>sh
$ cf push -c 'YOUR_TASK_LIB_COMMAND &amp;&amp; sleep infinity' -i 1 --no-route
</code></p>

<p>We're overriding the default start command, setting it to run the command for
our task library, e.g. rake db:migrate.</p>

<p>The <em>sleep infinity</em> command stops the application exiting once the task runner
has finished. If this happens, the platform will assume that application has
crashed and restart it.</p>

<p>Also, the task runner will not be binding to a port so
we need to use the <em>--no-route</em> argument to stop the platform assuming the
deploy has timed out.</p>

<p>Setting the deploy to a single instance stops the command being executed more than once.</p>

<p>Checking the logs to verify the task runner has finished correctly, we can now
redeploy our application. Using the <em>null</em> start command will force the platform to use the buildpack default
rather than our previous option.</p>

<p><code>sh
$ cf push -c 'null'
</code></p>

<h2>Running Tasks Before Startup</h2>

<p>If we're regularly running administrative tasks, we should incorporate the
task execution into our normal application startup. Once the
task command has finished successfully, we start the application as normal.</p>

<p>Applications may have multiple instances running, we need to ensure
the tasks are only executed by one instance.</p>

<p>The following custom start command will execute tasks during startup,
using the CF_INSTANCE_ID environment variable to enforce execution at most-once.</p>

<pre>
[ $CF_INSTANCE_INDEX -eq 0 ]] && node lib/tasks/runner.js; node app.js
</pre>


<p>With this approach, tasks will be automatically executed during regular deployments
without any manual intervention.</p>

<p><strong>Hurrah!</strong></p>

<h2>Managing tasks for Node.js applications</h2>

<p>If you're running Node.js applications on Cloud Foundry, <a href="https://github.com/IBM-Bluemix/oneoff">oneoff</a> is a task library that helps
you define <em>tasks as code</em> and integrates with the Cloud Foundry runtime. The module handles
all the complexities with automating tasks during deployments across multi-instance applications.</p>

<p>{% blockquote %}
oneoff provides the following features...</p>

<ul>
<li>ensure tasks are completed before application startup</li>
<li>coordinating app instances to ensure at-most once task execution</li>
<li>automagically discovering tasks from the task directory</li>
<li>dependency ordering, ensure task a completes before task b starts</li>
<li>parallel task execution</li>
<li>ignore completed tasks in future deployments
{% endblockquote %}</li>
</ul>


<p>Check it out to help make writing <em>tasks as code</em> for Node.js applications much easier!</p>

<p>Full details on usage are available in the <a href="https://github.com/IBM-Bluemix/oneoff/blob/master/README.md">README</a>.</p>

<h2>Conclusion</h2>

<p>Running one-off tasks for application configuration is a normal part of any development project.</p>

<p>Carrying out these tasks manually used to be the norm, but with the devops movement we now prefer
automated configuration rather manual intervention. Relying on manual configuration steps to deploy applications restricts
our ability to implement continuous delivery.</p>

<p>Cloud Foundry is an opinionated platform, actively discouraging the creation of snowflake environments.</p>

<p>Whilst it is still possible to manually run administrative tasks, either by connecting to bound services locally or using
a remote console, it's preferable to describe our tasks as code and let the platform handle it.</p>

<p>Using custom start commands, we can deploy applications which run tasks automatically during their normal startup procedure.</p>
]]></content>
  </entry>
  
</feed>
