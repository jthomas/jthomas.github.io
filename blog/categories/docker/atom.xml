<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: docker | James Thomas]]></title>
  <link href="http://jthomas.github.com/jthomas/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://jthomas.github.com/jthomas/"/>
  <updated>2015-07-01T16:36:29+01:00</updated>
  <id>http://jthomas.github.com/jthomas/</id>
  <author>
    <name><![CDATA[James Thomas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cloud Foundry Custom Buildpacks]]></title>
    <link href="http://jthomas.github.com/jthomas/blog/2015/03/04/cloud-foundry-custom-buildpacks/"/>
    <updated>2015-03-04T13:25:00+00:00</updated>
    <id>http://jthomas.github.com/jthomas/blog/2015/03/04/cloud-foundry-custom-buildpacks</id>
    <content type="html"><![CDATA[<p>Cloud Foundry <a href="http://docs.cloudfoundry.org/buildpacks/">Buildpacks</a> provide runtime and framework support for applications. Users can rely on the built-in selection for Java, NodeJS, Python, etc. or additional <a href="https://github.com/cloudfoundry-community/cf-docs-contrib/wiki/Buildpacks">community buildpacks</a> from Github.</p>

<p>Buildpacks are open-source, making them simple to customise and include  libraries needed by your application.</p>

<p><a href="https://github.com/jthomas/doctor-watson">Doctor Watson</a> uses an <a href="https://www.npmjs.com/package/sox">NPM module</a> that relies on a command-line application, <a href="sox.sourceforge.net">SOX</a>, being installed in the runtime environment.</p>

<p>Making this command-line application available on the platform required the project to create a <a href="https://github.com/jthomas/nodejs-buildpack">custom NodeJS buildpack</a>.</p>

<p>This was the first time I've needed to create a custom buildpack. Documenting the steps below will hopefully provide a guide for other people wanting to do the same.</p>

<p>Overall, the process was straightforward and left me with a greater understanding of how buildpacks works.</p>

<h2>SOX Audio Processing Library</h2>

<p>We're using the SOX package within Doctor Watson to up-sample an audio file.
This module depends on the command-line SOX audio processing utility being installed and available on the command line. SOX is an open-source C application.</p>

<h2>Buildpack Internals</h2>

<p>Cloud Foundry Buildpacks are Git repositories which must contain three shell scripts under the "bin" directory.</p>

<ul>
<li>detect - Does this buildpack apply to this application?</li>
<li>compile - Build the runtime used to execute the application</li>
<li>release - Controls how the application should be executed</li>
</ul>


<p>These shell scripts can be modified to perform any task necessary for an application runtime.</p>

<p>We're starting with the <a href="https://github.com/cloudfoundry/nodejs-buildpack">default NodeJS buildpack</a>.</p>

<p>The <a href="https://github.com/cloudfoundry/nodejs-buildpack/blob/master/bin/compile">"bin/compile"</a> script installs the correct NodeJS version, NPM modules and sets up the runtime environment to start the application. When the script is ran, a command line argument will give a directory path to place files needed at runtime.</p>

<p>We will need to install the SOX binary and dependent libraries under this directory path.</p>

<p>One method for doing this would be downloading the SOX source code and compiling during deployment, before installing the created binaries into the correct location.</p>

<p>Unfortunately, compiling from source during each deployment would add an unacceptable delay.</p>

<p><em>Therefore, most buildpacks use pre-built binaries, which are downloaded and moved to the build directory during deployment, saving a huge amount of time.</em></p>

<h2>Creating the pre-built binary archive</h2>

<p>Rather than manually creating our binaries from source, we can pull them from the Ubuntu package manager which already maintains a pre-built set of binaries for the <a href="https://packages.debian.org/unstable/sound/sox">SOX package</a>.</p>

<p>Packaging the binary and any dynamic libraries dependencies into an archive file, this can be stored in the buildpack repository for extraction during deployment.</p>

<p>We need to ensure the pre-built binaries were compiled for the same host environment that Cloud Foundry will use to run our application.</p>

<p>Using the cf stacks command, we can see the platforms details.</p>

<p>``` sh
[13:51:45 ~]$ cf stacks
Getting stacks in org james.thomas@uk.ibm.com / space dev as james.thomas@uk.ibm.com...
OK</p>

<p>name      description
lucid64   Ubuntu 10.04
seDEA     private
[13:53:10 ~]$
```</p>

<p>Now we just need access to the same platform to run the package manager on...</p>

<p>Docker to the rescue!</p>

<h2>Using Docker</h2>

<p>We're going to use Docker to run a new container with the same operating system as the Cloud Foundry environment. Using this we can install the SOX package using 'apt-get' and extract all the installed files.</p>

<p>``` sh
[13:56:46 ~]$ docker run -t -i  ubuntu:10.04 /bin/bash
root@7fdb1e9047e1:/#
root@7fdb1e9047e1:/# apt-get install sox
root@7fdb1e9047e1:/# which sox
/usr/bin/sox
root@7fdb1e9047e1:/# ldd /usr/bin/sox</p>

<pre><code>linux-vdso.so.1 =&gt;  (0x00007fff2819f000)
libsox.so.1 =&gt; /usr/lib/libsox.so.1 (0x00007f0f32a94000)
libltdl.so.7 =&gt; /usr/lib/libltdl.so.7 (0x00007f0f3288a000)
libdl.so.2 =&gt; /lib/libdl.so.2 (0x00007f0f32685000)
libpng12.so.0 =&gt; /lib/libpng12.so.0 (0x00007f0f3245e000)
libmagic.so.1 =&gt; /usr/lib/libmagic.so.1 (0x00007f0f32242000)
libz.so.1 =&gt; /lib/libz.so.1 (0x00007f0f3202a000)
libgomp.so.1 =&gt; /usr/lib/libgomp.so.1 (0x00007f0f31e1c000)
libgsm.so.1 =&gt; /usr/lib/libgsm.so.1 (0x00007f0f31c0e000)
libm.so.6 =&gt; /lib/libm.so.6 (0x00007f0f3198a000)
libpthread.so.0 =&gt; /lib/libpthread.so.0 (0x00007f0f3176d000)
libc.so.6 =&gt; /lib/libc.so.6 (0x00007f0f313eb000)
/lib64/ld-linux-x86-64.so.2 (0x00007f0f32d28000)
librt.so.1 =&gt; /lib/librt.so.1 (0x00007f0f311e2000)
</code></pre>

<p>root@7fdb1e9047e1:/#
```</p>

<p>Now we have the location of the SOX binary along with a list of the dynamic libraries it depends on.</p>

<p><em>How do we know which of those libraries were already available in the operating system and those the package manager installed?</em></p>

<p>Using Docker diff, we can compare the container to the base image.</p>

<p><code>sh
[14:02:43 ~]$ docker diff 7fdb1e9047e1 | grep '\.so\.'
C /etc/ld.so.cache
C /etc/ld.so.conf.d
A /etc/ld.so.conf.d/libasound2.conf
C /lib/libgcc_s.so.1
A /usr/lib/libFLAC.so.8
A /usr/lib/libFLAC.so.8.2.0
A /usr/lib/libasound.so.2
A /usr/lib/libasound.so.2.0.0
A /usr/lib/libgomp.so.1
A /usr/lib/libgomp.so.1.0.0
....
</code></p>

<p>This command will output list of files that have been modified. Grepping this for the list of dependencies we have, it's easy to extract those which are new.</p>

<p>We can now copy the files needed from the container filesystem to our local host and bundle into an <a href="https://github.com/jthomas/nodejs-buildpack/blob/master/vendor/sox.tar.gz">archive in the "vendor" directory</a>.</p>

<p><code>sh
[14:02:43 ~]$ docker cp 7fdb1e9047e1:/usr/bin/sox .
</code></p>

<h2>Modifying the "bin/compile" script</h2>

<p>With the pre-built binary package available in the buildpack repository, we just need to extract this during deployment from the vendor directory into the build directory.</p>

<p>Modifying the PATH and LD_LIBRARY_PATH variables will expose the binary during runtime and ensure the dynamic libraries are recognised.</p>

<p>``` sh</p>

<h1>Add SOX binary and libraries to path</h1>

<p>status "Adding SOX library support"
tar xzf $bp_dir/vendor/sox.tar.gz -C $build_dir/vendor/</p>

<h1>Update the PATH</h1>

<p>status "Building runtime environment"
mkdir -p $build_dir/.profile.d
echo "export PATH=\"\$HOME/vendor/node/bin:\$HOME/bin:\$HOME/node_modules/.bin:\$HOME/vendor/:\$PATH\";" > $build_dir/.profile.d/nodejs.sh
echo "export LD_LIBRARY_PATH=\"\$HOME/vendor/libs/\";" >> $build_dir/.profile.d/nodejs.sh
```</p>

<h2>Using the custom buildpack</h2>

<p>Once the buildpack modifications have been committed to the <a href="https://github.com/jthomas/nodejs-buildpack">external Github repository</a>, the application manifest can be modified to point to this new location.</p>

<pre>
---
applications:
- name: doctor-watson
  memory: 256M 
  buildpack: https://github.com/jthomas/nodejs-buildpack.git
  command: node app.js
  services:
  - twilio
  - speech_to_text
  - question_and_answer
</pre>


<p>... at this point all we have to do is deploy our application again to take advantage of the modified runtime.</p>

<h2>Conclusion</h2>

<p>Buildpacks are a fantastic feature of the Cloud Foundry, allowing the platform to support for almost any runtime. Using open-source Git repositories means you can build on any existing buildpack.</p>

<p>For Doctor Watson, we were able to add a command line binary, built in another language, to the NodeJS runtime. Docker was a great tool when developing our custom buildpack.</p>

<p>If you want more information on customising buildpacks, check out the Cloud Foundary <a href="http://docs.cloudfoundry.org/buildpacks/custom.html">documentation</a>.</p>

<p>Source code for the custom buildpack we created is available <a href="https://github.com/jthomas/nodejs-buildpack">here</a>.</p>
]]></content>
  </entry>
  
</feed>
