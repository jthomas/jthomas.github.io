<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: openwhisk | James Thomas]]></title>
  <link href="http://jamesthom.as/blog/categories/openwhisk/atom.xml" rel="self"/>
  <link href="http://jamesthom.as/"/>
  <updated>2017-04-27T17:28:25+01:00</updated>
  <id>http://jamesthom.as/</id>
  <author>
    <name><![CDATA[James Thomas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Packages in OpenWhisk]]></title>
    <link href="http://jamesthom.as/blog/2017/04/27/python-packages-in-openwhisk/"/>
    <updated>2017-04-27T17:15:00+01:00</updated>
    <id>http://jamesthom.as/blog/2017/04/27/python-packages-in-openwhisk</id>
    <content type="html"><![CDATA[<p>OpenWhisk's Python runtime <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/reference.md#python-actions">includes popular third-party libraries</a> like requests, scrapy and simplejson. Developers don't have to manually install packages to use those libraries.</p>

<p><em>Great, but what about using other libraries that aren't pre-installed?</em></p>

<p>In a <a href="./blog/2016/11/28/npm-modules-in-openwhisk/">previous blog post</a>, we showed how to deploy Node.js actions from zip files containing third-party modules. These modules are then made available in the Node.js runtime.</p>

<p><strong><a href="https://github.com/openwhisk/openwhisk/pull/1940">Recent updates</a> to OpenWhisk allow us to use the same approach with the Python runtime!</strong></p>

<h2>Python Packages</h2>

<p>Python packages can be installed using the <a href="https://pypi.python.org/pypi/pip">pip tool</a>. This can be used to install individual packages or a series of dependencies from an external file.</p>

<p><code>
$ pip install blah
$ pip install -r requirements.txt
</code></p>

<p>pip defaults to installing packages in a global location (<a href="http://stackoverflow.com/questions/31384639/what-is-pythons-site-packages-directory">site-packages</a>) which is shared between all users. This can cause issues when different projects require different versions of the same package.</p>

<h3>virtualenv</h3>

<p><a href="http://python-guide-pt-br.readthedocs.io/en/latest/dev/virtualenvs/">virtualenv</a> is a tool that solves this issue by creating virtual python environments for projects. The virtual environment includes a custom <code>site-packages</code> folder to install packages into.</p>

<p><code>
$ virtualenv env
Using base prefix '/Library/Frameworks/Python.framework/Versions/3.6'
New python executable in /private/tmp/env/bin/python3.6
Also creating executable in /private/tmp/env/bin/python
Installing setuptools, pip, wheel...done.
</code></p>

<p>OpenWhisk <a href="https://github.com/openwhisk/openwhisk/pull/1940">recently added support</a> for using virtualenv in the Python runtime.</p>

<h3>custom packages on openwhisk</h3>

<p>OpenWhisk actions can be created from a zip file <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/actions.md#packaging-an-action-as-a-nodejs-module">containing source files and other resources</a>.</p>

<p>If the archive includes a virtual Python environment folder, the platform runs the <code>./bin/activate_this.py</code> script before executing Python actions. This script modifies the module search path to include the local <code>site-packages</code> folder.</p>

<p><em>This will only happen during "cold" activations.</em></p>

<p><strong>This feature comes with the following restrictions.</strong></p>

<ul>
<li>Virtual Python environment must be in a folder called <code>virtualenv</code> under the top-level directory.</li>
<li>Packages must be available for the Python runtime being used in OpenWhisk (2.7 or 3.6).</li>
</ul>


<p>Let's look at an example of building an OpenWhisk Python action which uses an external Python package.</p>

<h3>Python Package Example</h3>

<p>The <a href="https://pypi.python.org/pypi/pyjokes">pyjokes</a> package provides a library for generating (terrible) jokes for programmers. Let's turn this package into an API (Jokes-as-a-Service!) using the Python runtime on OpenWhisk.</p>

<p>Start by creating a new directory for your project and set up the virtual Python environment.</p>

<p><code>sh
$ mkdir jokes; cd jokes
$ virtualenv virtualenv
Using base prefix '/Library/Frameworks/Python.framework/Versions/3.6'
New python executable in /tmp/jokes/virtualenv/bin/python3.6
Also creating executable in /tmp/jokes/virtualenv/bin/python
Installing setuptools, pip, wheel...done.
$ source virtualenv/bin/activate
(virtualenv) $ pip install pyjokes
Collecting pyjokes
  Using cached pyjokes-0.5.0-py2.py3-none-any.whl
Installing collected packages: pyjokes
Successfully installed pyjokes-0.5.0
(virtualenv) $
</code></p>

<p>In the project directory, create a new file (<code>__main__.py</code>) and paste the following code.</p>

<p>```python
import pyjokes</p>

<p>def joke(params):</p>

<pre><code>return {"joke": pyjokes.get_joke()}
</code></pre>

<p>```</p>

<p>Check the script works with the Python intepreter.</p>

<p>```sh
(virtualenv) $ python -i .</p>

<blockquote><blockquote><blockquote><p>joke({})
{'joke': 'What do you call a programmer from Finland? Nerdic.'}</p>

<p>```</p></blockquote></blockquote></blockquote>

<p>Add the <code>virtualenv</code> folder and Python script to a new zip file.</p>

<p><code>
$ zip -r jokes.zip virtualenv __main__.py
  adding: virtualenv/ (stored 0%)
  adding: virtualenv/.Python (deflated 65%)
  adding: virtualenv/bin/ (stored 0%)
  adding: virtualenv/bin/activate (deflated 63%)
  ...
$ ls
__main__.py  jokes.zip   virtualenv
</code></p>

<p>Create a new OpenWhisk action for the Python runtime using the <code>wsk</code> cli.</p>

<p><code>
$ wsk action create jokes --kind python:3 --main joke jokes.zip
ok: created action jokes
</code></p>

<p>Invoking our new action will return (bad) jokes on-demand using the third-party Python package.</p>

<p>```
$ wsk action invoke jokes --blocking --result
{</p>

<pre><code>"joke": "Software salesmen and used-car salesmen differ in that the latter know when they are lying."
</code></pre>

<p>}
```</p>

<h3>Installing Packages With Docker</h3>

<p>In the example above, the Python runtime used in development (v3.6) matched the OpenWhisk runtime environment. Packages installed using <code>virtualenv</code> must be for the same major and minor versions of the Python runtime used by OpenWhisk.</p>

<p>OpenWhisk publishes the runtime environments as <a href="https://hub.docker.com/u/openwhisk/">Docker images on Docker Hub</a>.</p>

<p>Running containers from <a href="https://hub.docker.com/r/openwhisk/python3action/">those runtime images</a> provides a way to download packages for the correct environment.</p>

<p><code>
$ docker run --rm -v "$PWD:/tmp" openwhisk/python3action sh \
  -c "cd tmp; virtualenv virtualenv; source virtualenv/bin/activate; pip install pyjokes;"
Using base prefix '/usr/local'
New python executable in /tmp/virtualenv/bin/python3.6
Also creating executable in /tmp/virtualenv/bin/python
Installing setuptools, pip, wheel...done.
Collecting pyjokes
  Downloading pyjokes-0.5.0-py2.py3-none-any.whl
Installing collected packages: pyjokes
Successfully installed pyjokes-0.5.0
$
</code></p>

<p>This will leave you a <code>virtualenv</code> folder in the current directory with packages for the correct Python runtime.</p>

<h3>Speeding Up Deployments</h3>

<p>Peeking inside the <code>virtualenv</code> folder reveals a huge number of files to set up the virtual Python environment. If we just want to use a third-party package from the local <code>site-packages</code> folder, most of those files are unnecessary.</p>

<p><em>Adding this entire folder to the zip archive will unnecessarily inflate the file size. This will slow down deployments and increase execution time for cold activations. OpenWhisk also has a maximum size for action source code of 48MB.</em></p>

<p>Manually including individual <code>site-packages</code> folders, rather than the entire <code>virtualenv</code> directory, will ensure the archive file only contains packages being used. We must also add the Python script (<code>virtualenv/bin/activate_this.py</code>) executed by OpenWhisk to modify the module search path.</p>

<p><code>
$ zip -r jokes_small.zip virtualenv/bin/activate_this.py virtualenv/lib/python3.6/site-packages/pyjokes __main__.py
updating: virtualenv/bin/activate_this.py (deflated 54%)
updating: virtualenv/lib/python3.6/site-packages/pyjokes/ (stored 0%)
updating: virtualenv/lib/python3.6/site-packages/pyjokes/__init__.py (deflated 20%)
updating: virtualenv/lib/python3.6/site-packages/pyjokes/jokes_de.py (deflated 29%)
updating: virtualenv/lib/python3.6/site-packages/pyjokes/jokes_en.py (deflated 61%)
updating: virtualenv/lib/python3.6/site-packages/pyjokes/jokes_es.py (deflated 40%)
updating: virtualenv/lib/python3.6/site-packages/pyjokes/pyjokes.py (deflated 68%)
updating: __main__.py (deflated 18%)
$ ls -lh
total 40984
-rw-r--r--  1 james  wheel    74B 21 Apr 11:01 __main__.py
-rw-r--r--  1 james  wheel    20M 21 Apr 11:07 jokes.zip
-rw-r--r--  1 james  wheel   9.3K 21 Apr 13:36 jokes_small.zip
drwxr-xr-x  6 james  wheel   204B 21 Apr 11:25 virtualenv
</code></p>

<p>The archive file is now less than ten kilobytes! üèÉ</p>

<h4>With The Serverless Framework</h4>

<p><a href="https://serverless.com/">The Serverless Framework</a> is a popular open-source framework for building serverless applications. This framework handles the configuration, packaging and deployment of your serverless application.</p>

<p>OpenWhisk is supported through a <a href="https://www.npmjs.com/package/serverless-openwhisk">provider plugin</a>. <a href="https://medium.com/openwhisk/serverless-framework-and-openwhisk-plugin-update-v0-6-1339cfdcd2d2">Recent versions</a> of the plugin added support for the Python runtime environment.</p>

<p>Using the <a href="https://serverless.com/framework/docs/providers/openwhisk/guide/serverless.yml/">application configuration file</a> for the framework, users can add <code>include</code> and <code>exclude</code> parameters to control the contents of the archive file before deployment.</p>

<p>Here's an example of the configuration needed to only include the necessary files for the application above.</p>

<p>```yaml
service: pyjokes</p>

<p>provider:
  name: openwhisk
  runtime: python:3</p>

<p>functions:
  jokes:</p>

<pre><code>handler: handler.joke
</code></pre>

<p>plugins:
  - serverless-openwhisk</p>

<p>package:
  exclude:</p>

<pre><code>- virtualenv/**
- '!virtualenv/bin/activate_this.py'
- '!virtualenv/lib/python3.6/site-packages/pyjokes/**'
</code></pre>

<p>```</p>

<h3>conclusion</h3>

<p>Python has a huge community of third-party packages for everything from parsing JSON, making HTTP requests and even generating jokes. OpenWhisk already provided a number of the most popular packages within the Python runtime.</p>

<p>Users can install additional packages locally using the <code>pip</code> and <code>virtualenv</code> tools. Bundling those files within the deployment archive means they are extracted into the OpenWhisk Python runtime environment.</p>

<p>Recent changes to the Python runtime allows the platform to automatically add local package folders to the module search path.</p>

<p><strong>This means Python functions running on OpenWhisk can now use any third-party library as if it was installed globally.</strong></p>

<p>Hurrah üëå!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building an SMS Bot for Slack.]]></title>
    <link href="http://jamesthom.as/blog/2017/03/20/smsbot/"/>
    <updated>2017-03-20T16:02:00+00:00</updated>
    <id>http://jamesthom.as/blog/2017/03/20/smsbot</id>
    <content type="html"><![CDATA[<p>This is <a href="https://github.com/ibmets/smsbot">smsbot</a>.</p>

<p>{% img /images/smsbot/slack_text_hidden.jpg %}</p>

<p>It provides an integration with Slack that connects SMS messages into channels. People can text an external number and have their messages posted into the channel. Channel users can respond to the messages and have their response sent back to the sender using SMS.</p>

<p>{% blockquote %}</p>

<p>smsbot was developed in under a few hours and less than one hundred lines of code using a serverless cloud platform.</p>

<p>{% endblockquote %}</p>

<p>Want to understand how it works? Let's find out‚Ä¶</p>

<p>The first challenge was how to programmatically send and receive SMS messages.</p>

<p><em><strong>Want to deploy smsbot yourself? Follow the <a href="#Deployment">instructions</a> at the bottom or check out the <a href="https://github.com/ibmets/smsbot">Github repository</a>.</strong></em></p>

<h2>Twilio</h2>

<p>{% img http://www.timothylutts.com/wp-content/uploads/2016/09/twilio.jpg %}</p>

<p><a href="https://twilio.com">Twilio</a> provides a platform for building SMS, voice and messaging applications using an API.</p>

<p>Developers can <a href="https://www.twilio.com/console/phone-numbers">register phone numbers</a> through the service that invoke webhooks for incoming calls and SMS messages. Webhooks are passed message details and return a custom markup language (TwilML) to encode the instructions on how to respond to the request.</p>

<p>The platform also provides a REST API to <a href="https://www.twilio.com/sms/api">initiate phone calls and SMS messages</a>.</p>

<p><em>We now have a way to handle text messages for our bot, how do we integrate a new bot in Slack?</em></p>

<h2>Slack</h2>

<p>{% img http://stratejos.ai/img/logos/slack-logo.png %}</p>

<p><a href="https://slack.com">Slack</a> also provides a webhook-based mechanism to integrate custom bots into the platform. The platform has two different integrations‚Ä¶</p>

<h3>Incoming Webhooks.</h3>

<p>Provide a way to post messages into Slack from external sources. It provides a custom URL that supports HTTP requests with a JSON payload. These requests are turned into channel messages. The JSON payload is used to control the content and formatting of the message.</p>

<p><a href="https://api.slack.com/incoming-webhooks">https://api.slack.com/incoming-webhooks</a></p>

<h3>Outgoing Webhooks</h3>

<p>Allow you to listen for messages in channels without using the full real-time API. Slack sends HTTP requests to registered URLs when specific trigger words appear in channel messages. The HTTP request body contains the message details.</p>

<p><a href="https://api.slack.com/outgoing-webhooks">https://api.slack.com/outgoing-webhooks</a></p>

<p><em>Now we just need a way to write simple HTTP services to listen for webhook requests‚Ä¶</em></p>

<h2>OpenWhisk</h2>

<p>{% img http://openwhisk.org/images/apache-openwhisk.jpg %}</p>

<p><a href="http://openwhisk.org">OpenWhisk</a> is an open-source serverless cloud platform. <a href="https://martinfowler.com/articles/serverless.html">Serverless platforms</a> make it easy to create microservices in the cloud without having to set up or manage any infrastructure.</p>

<p>Developers push their code directly into the platform. The platform will instantiate the runtime and invoke the code on-demand for each request. Serverless functions can be <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/apigateway.md">exposed as HTTP endpoints</a> or connected to <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/catalog.md">event sources</a> like <a href="https://github.com/openwhisk/openwhisk-package-kafka/blob/master/README.md">message queues</a> or <a href="https://github.com/openwhisk/openwhisk-package-cloudant/blob/master/README.md">databases</a>.</p>

<p>Serverless platforms make it easy to create simple HTTP services to handle webhook requests.</p>

<h3>Web Actions</h3>

<p><a href="https://medium.com/openwhisk/serverless-http-handlers-with-openwhisk-90a986cc7cdd#.rki6bwjgu">Web Actions</a> are a new feature in OpenWhisk for exposing serverless functions as simple HTTP endpoints. Functions have access to the full HTTP request and can control the HTTP response returned. This method is suitable for simple public endpoints that do not need more enterprise features supported by the <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/apigateway.md">API gateway</a>.</p>

<p>Web Actions are available at the following <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/webactions.md">platform API path</a>.</p>

<p><code>
https://{APIHOST}/api/v1/experimental/web/{USER_NAMESPACE}/{PACKAGE}/{ACTION_NAME}.{TYPE}
</code></p>

<ul>
<li><em>APIHOST</em> - platform endpoint e.g. <em>openwhisk.ng.bluemix.net.</em></li>
<li><em>USER_NAMESPACE</em> - must be explicit and cannot use the default namespace (_).</li>
<li><em>PACKAGE</em> - action package or <code>default</code>.</li>
<li><em>ACTION_NAME</em> - function identifier.</li>
<li><em>TYPE</em> - <code>.json</code>, <code>.html</code>, <code>.text</code> or <code>.http</code>.</li>
</ul>


<h3>Example</h3>

<p>Here's a simple Web Actions that returns HTML content when invoked through the API.</p>

<p>```javascript
function main(args) {</p>

<pre><code>var msg = "you didn&amp;#39;t tell me who you are."
if (args.name) {
    msg = `hello ${args.name}!`
}
return {body:
   `&lt;html&gt;&lt;body&gt;&lt;h3&gt;&lt;center&gt;${msg}&lt;/center&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;`}
</code></pre>

<p>}
```</p>

<p>Actions can be turned into web-accessible actions by setting a custom annotation.</p>

<p><code>
$ wsk action create greeting source.js --annotation web-export true
</code></p>

<p>The <code>greeting</code> function can then be invoked through a HTTP request to the following endpoint.</p>

<p><code>https://openwhisk.ng.bluemix.net/api/v1/experimental/web/user@host.com_dev/default/greeting.http?name=James</code></p>

<p>```sh
$ http post https://openwhisk.ng.bluemix.net/api/v1/experimental/web/user@host.com_dev/default/html_greeting.http?name=James
HTTP/1.1 200 OK
...</p>

<p><html><body><h3><center>hello James!</center></h3></body></html>
```</p>

<h2>Twilio &lt;=> Slack</h2>

<p>OpenWhisk Web Actions are a great solution for creating webhook endpoints. Connecting Twilio to Slack (and vice-versa) can be implemented using two different OpenWhisk Web Actions.</p>

<ul>
<li><strong>Twilio Webhook.</strong> Invoked for SMS messages. Uses the Slack Incoming Webhook to create a bot messages from content.
‚Äã</li>
<li><strong>Slack Outgoing Webhook.</strong> Invoked for channel replies. Uses Twilio API to send replies as SMS messages.</li>
</ul>


<p>Let's have a look at the Twilio webhook first‚Ä¶</p>

<h3>Twilio Webhook</h3>

<p>When a new SMS message is received, we want to post this bot message into our Slack channel.</p>

<p>Twilio allows developers to <a href="https://www.twilio.com/docs/api/twiml/sms/twilio_request">configure webhooks</a> for each registered phone number. The webhook endpoint will be invoked for each SMS message that is received. Twilio can either send a HTTP POST request, with parameters in the body, or a HTTP GET request, with URL query parameters.</p>

<p>OpenWhisk Web Actions support both formats. Request parameters will be available as <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/webactions.md#http-context">properties on the function argument</a>.</p>

<p>Here's a simple Web Action that would log the message sender and content for each SMS received.</p>

<p><code>javascript
function main (params) {
  console.log(`Text message from ${params.From}: ${params.Body}`)
}
</code></p>

<h4>Creating Bot Messages From SMS</h4>

<p>When an SMS message is received, we need to send a HTTP POST to the <a href="https://api.slack.com/incoming-webhooks">Incoming Webhook URL</a>. The JSON body of the HTTP request is used to configure the channel message. Using the <code>username</code>, <code>icon_emoji</code> and and <code>text</code> properties allows us to customise our bot message.</p>

<p>OpenWhisk Actions in Node.js have <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/reference.md#javascript-runtime-environments">numerous popular NPM modules</a> pre-installed in the environment. This includes a <a href="https://github.com/request/request">HTTP client library</a>. This code snippet demonstrates sending the HTTP request to create out bot message. The Slack Webhook URL is bound as a <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/actions.md#setting-default-parameters">default parameter</a> to the action.</p>

<p>```javascript
const request = require('request')</p>

<p>const slack_message = text => ({
  username: 'smsbot',
  icon_emoji: ':phone:',
  text
})</p>

<p>function main (params) {<br/>
  return new Promise(function (resolve, reject) {</p>

<pre><code>request.post({
  body: slack_message(`Text message from ${params.From}: ${params.Body}`),
  json: true,
  url: params.slack.webhook
}, err =&gt; {
  if (err) return reject(err);
  resolve();
})
</code></pre>

<p>  })
}
```</p>

<p>Returning a Promise ensures the request is completed before the function exits.</p>

<h4>Sending Acknowledgement Message</h4>

<p>Returning <a href="https://www.twilio.com/docs/api/twiml">TwilML</a> content allows us to control the response from Twilio to the incoming message.</p>

<p>This snippet would send an SMS reply to sender with the content "Hello World!".</p>

<p><code>xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Response&gt;
  &lt;Message&gt;Hello World!&lt;/Message&gt;
&lt;/Response&gt;
</code></p>

<p><a href="https://www.npmjs.com/package/twilio">Twilio's client library</a> for Node.js can be used to programatically generate TwilML.</p>

<p><code>javascript
const twilio = require('twilio')
const resp = new twilio.TwimlResponse()
const twilml = resp.message('Thanks for letting us know.').toString()
</code></p>

<p>Returning XML content as the HTTP response requires us to set the response headers, body and status code in the Web Action.</p>

<p>```javascript
function main () {
  const xml = '...'
  return {</p>

<pre><code>headers: {
  'Content-Type': 'text/xml'
},
code: 200,
body: xml
</code></pre>

<p>  }
}
```</p>

<h4>Web Action Source</h4>

<p>Adding the XML response code into the existing function completes the OpenWhisk Web Action required to handle incoming SMS messages.</p>

<p>```javascript
const request = require('request')
const twilio = require('twilio')</p>

<p>const resp = new twilio.TwimlResponse()
const twilml = resp.message('Thanks for letting us know.').toString()</p>

<p>const response = {
  headers: {</p>

<pre><code>'Content-Type': 'text/xml'
</code></pre>

<p>  },
  code: 200,
  body: twilml
}</p>

<p>const slack_message = text => ({
  username: 'smsbot',
  icon_emoji: ':phone:',
  text
})</p>

<p>function main (params) {<br/>
  return new Promise(function (resolve, reject) {</p>

<pre><code>request.post({
  body: slack_message(`Text message from ${params.From}: ${params.Body}`),
  json: true,
  url: params.slack.webhook
}, err =&gt; {
  if (err) return reject(err);
  resolve(response);
})
</code></pre>

<p>  })
}
```</p>

<h4>Register Webhook</h4>

<p>Once we have deployed the Web Action, we can configure the Twilio SMS webhook endpoint to use following URL.</p>

<p><code>https://openwhisk.ng.bluemix.net/api/v1/experimental/web/user@email.com_dev/default/smsbot-dev-incoming.http</code></p>

<p>{% img /images/smsbot/twilio_sms_webhook.png %}</p>

<h3>Slack Outgoing Webhook</h3>

<p>When someone sends a channel message to the bot, smsbot should send that content as an SMS message to the last person who sent an SMS to the channel. An <a href="https://api.slack.com/custom-integrations/outgoing-webhooks">Outgoing Webhook</a> will be used to trigger the bot.</p>

<p>Outgoing Webhooks have a configurable trigger word. Channel messages which start with this word are send as HTTP requests to the list of URLs registered for that webhook. We will use <code>smsbot</code> as our trigger word.</p>

<p>{% img /images/smsbot/outgoing_webhook_trigger.png %}</p>

<h4>Request Parameters</h4>

<p>Slack sends the following parameters for each channel message.</p>

<p><code>
token=XXXXXXXXXXXXXXXXXX
team_id=T0001
team_domain=example
channel_id=C2147483705
channel_name=test
timestamp=1355517523.000005
user_id=U2147483697
user_name=Steve
text=googlebot: What is the air-speed velocity of an unladen swallow?
trigger_word=googlebot:
</code></p>

<p>In OpenWhisk Web Actions, these parameters will be available on the function argument object.</p>

<p>Here's a simple Web Action that would parse and log the message contents when the webhook is fired.</p>

<p><code>javascript
function main (params) {
  const msg = params.text.slice(params.trigger_word.length + 1)
  console.log('channel message:', msg)
}
</code></p>

<p>When this webhook is fired, we need to add code to send an SMS message with the channel message.</p>

<h4>Sending SMS Messages</h4>

<p><a href="https://www.twilio.com/docs/api/rest">Twilio's API</a> allows us to programatically <a href="https://www.twilio.com/docs/api/rest/sending-messages">send SMS messages</a> from our registered numbers.</p>

<p>This snippet shows you how to use their <a href="http://npmjs.com/package/twilio">Node.js client library</a> to send sample message.</p>

<p>```javascript
const twilio = require('twilio')
const creds = { account: '...', auth: '...' }</p>

<p>const client = twilio(creds.account, creds.auth)
const callback = (err, message) => {
  if (err) return console.log(err)
  console.log('sent sms message.')
}</p>

<p>client.messages.create({ to: '...', from: '...', body: 'hello world' }, callback)
```</p>

<p>The webhook should use this client library to send a message to the last person who send us an incoming message.</p>

<h4>Reply to Message Sender</h4>

<p>How can we determine who was the last person who sent a message to our bot? The Web Action processing the incoming messages is a separate service to the Web Action sending SMS messages.</p>

<p>Rather than setting up a database to share application state, the service can use Twilio's API to retrieve the received message details.</p>

<p>```javascript
const twilio = require('twilio')
const creds = { account: '...', auth: '...' }
const client = twilio(creds.account, creds.auth)</p>

<p>client.messages.list({to: '+44....'}, (err, data) => {
  const last = data.messages[0]
  console.log(<code>last message from: ${last.from}</code>)
})
```</p>

<h4>SMSBot Channel Response</h4>

<p><a href="https://api.slack.com/custom-integrations/outgoing-webhooks">Outgoing Webhooks</a> which respond with a JSON body will generate a new channel message.</p>

<p><code>json
{
  "username": "smsbot",
  "icon_emoji": ":phone:",
  "text": "sms sent to ..."
}
</code></p>

<h4>Web Action Source</h4>

<p>Combing the channel message parsing code with the snippets for sending SMS messages and obtaining the last message sender completes the Web Action needed to handle the Outgoing Webhook.</p>

<p>```javascript
const twilio = require('twilio')</p>

<p>const slack_message = text => ({
  username: 'smsbot',
  icon_emoji: ':phone:',
  text
})</p>

<p>function reply (params) {
  const client = twilio(params.twilio.account, params.twilio.auth)
  return new Promise((resolve, reject) => {</p>

<pre><code>client.messages.list({to: params.twilio.number}, (err, data) =&gt; {
if (err) return Promise.reject(err)

const last = data.messages[0]
const msg = params.text.slice(params.trigger_word.length + 1)
const options = { to: last.from, from: last.to, body: msg }
client.messages.create(options, (err, message) =&gt; {
    if (err) return Promise.reject(err)
    resolve(slack_message(`sms reply sent to ${last.from}`))
  })
})
</code></pre>

<p>  })
}
```</p>

<p>Twilio account credentials are bound as <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/actions.md#setting-default-parameters">default parameters</a> to the Web Action during deployment.</p>

<h2>Deployment</h2>

<p><a href="https://github.com/ibmets/smsbot">smsbot</a> is built using <a href="https://serverless.com/">The Serverless Framework</a>.</p>

<p>{% img https://cloud.githubusercontent.com/assets/20538501/24154626/b86ad64a-0e1f-11e7-8e12-979b8d194430.png %}</p>

<p>This framework makes building serverless applications really easy. The tool handles the entire configuration and deployment process for your serverless provider. OpenWhisk <a href="https://serverless.com/blog/openwhisk-integration-with-serverless/">recently released integration</a> with the framework through a provider plugin.</p>

<p><strong><em>Let's look at how to use the framework to deploy our serverless application‚Ä¶</em></strong></p>

<h3>OpenWhisk</h3>

<p>Register for an account with an OpenWhisk provider, e.g. <a href="https://console.ng.bluemix.net/">IBM Bluemix</a>.</p>

<p><a href="https://console.ng.bluemix.net/openwhisk/learn/cli">Set up</a> the <code>wsk</code> CLI and run the command to authenticate against the platform endpoint.</p>

<p><code>
wsk property set --apihost openwhisk.ng.bluemix.net --auth SECRET
</code></p>

<h3>Serverless Framework</h3>

<p>Install the <a href="https://github.com/serverless/serverless">The Serverless Framework</a> and the <a href="https://github.com/serverless/serverless-openwhisk">OpenWhisk provider plugin</a>.</p>

<p><code>
npm install --global serverless serverless-openwhisk
</code></p>

<h3>Source Code</h3>

<p>Download the <a href="https://github.com/jthomas/smsbot">source code</a> from Github and install the project dependencies.</p>

<p><code>
$ git clone https://github.com/ibmets/smsbot.git
$ cd smsbot
$ npm install
</code></p>

<p>Create a new file called <code>credentials.yml</code> with the following content.</p>

<p>```yaml
twilio:</p>

<pre><code>account:
auth:
number:
</code></pre>

<p>numbers:
slack:</p>

<pre><code>webhook:
</code></pre>

<p>```</p>

<h3>Twilio</h3>

<p>Register an account with Twilio and provision <a href="https://www.twilio.com/console/phone-numbers/search">a new phone number</a>. Make a note of the phone number. Retrieve the account identifier and auth token from the <a href="https://www.twilio.com/console">Twilio console</a>.</p>

<p>Fill in the account identifier, auth token and phone number in the <code>credentials.yml</code> file.</p>

<p>```yaml
twilio:</p>

<pre><code>account: AC_USER_ID
auth: AUTH_TOKEN
number: '+441234567890'
</code></pre>

<p>```</p>

<p><em>Important: the <code>twilio.number</code> property value must be a quoted string.</em></p>

<h3>Phone Numbers</h3>

<p>During Twilio's free trial, you will need <a href="https://support.twilio.com/hc/en-us/articles/223136107-How-does-Twilio-s-Free-Trial-work-">manually verify each phone number</a> that you want to send messages to.</p>

<p>Fill in all verified numbers in <code>credentials.yml</code>.</p>

<p>```yaml
numbers:</p>

<pre><code>'+441234567890': Joe Smith
'+441234567891': Jane Smith
</code></pre>

<p><code>``
*Important: the</code>numbers` property values must be a quoted strings.*</p>

<h3>Incoming Webhook</h3>

<p>Create a new <a href="https://api.slack.com/incoming-webhooks">Incoming Webhook</a> integration for the Slack channel messages should appear in.</p>

<p>Fill in the <code>slack.webhook</code> property in <code>credentials.yml</code> with this url.</p>

<p>```yaml
slack:</p>

<pre><code>webhook: https://hooks.slack.com/services/XXXX/YYYY/ZZZZ
</code></pre>

<p>```</p>

<h3>Deploy Application</h3>

<p>Use The Serverless Framework to deploy your application.</p>

<p>```
$ serverless deploy
Serverless: Packaging service...
Serverless: Compiling Functions...
Serverless: Compiling API Gateway definitions...
Serverless: Compiling Rules...
Serverless: Compiling Triggers &amp; Feeds...
Serverless: Deploying Functions...
Serverless: Deployment successful!</p>

<p>Service Information
platform:   openwhisk.ng.bluemix.net
namespace:  _
service:    smsbot</p>

<p>actions:
smsbot-dev-incoming    smsbot-dev-reply</p>

<p>triggers:
<strong>no triggers deployed</strong></p>

<p>rules:
<strong>no rules deployed</strong></p>

<p>endpoints:
<strong>no routes deployed</strong>
```</p>

<h3>Twilio Webhook</h3>

<p>On the <a href="https://www.twilio.com/console/phone-numbers/incoming">Phone Numbers</a> page in the Twilio console, configure the "<em>Messaging</em>" webhook URL.</p>

<p>Use this Web Action URL, replacing <code>user@host.com_dev</code> with your namespace.</p>

<p><code>https://openwhisk.ng.bluemix.net/api/v1/experimental/web/user@host.com_dev/default/smsbot-dev-incoming.http</code></p>

<p>{% img /images/smsbot/twilio_sms_webhook.png %}</p>

<h3>Outgoing Webhook</h3>

<p>Create a new <a href="https://api.slack.com/custom-integrations/outgoing-webhooks">Outgoing Webhook</a> integration for the Slack channel messages should appear in. Use <code>smsbot</code> as the <em>Trigger Word</em>.</p>

<p>Use this Web Action URL, replacing <code>user@host.com_dev</code> with your namespace.</p>

<p><code>https://openwhisk.ng.bluemix.net/api/v1/experimental/web/user@host.com_dev/default/smsbot-dev-reply.json</code></p>

<p>{% img /images/smsbot/outgoing_webhook_trigger.png %}</p>

<h3>Test it out!</h3>

<p>Send a text message to the phone number you registered through Twilio. smsbot should post the contents into Slack and send an SMS response with the message "<em>Thanks for letting us know!</em>".</p>

<p>{% img /images/smsbot/slack_text_hidden.jpg %}</p>

<p>If you send a channel message starting with the trigger word (<em>smsbot</em>), the phone number should receive a new SMS message with the message text.</p>

<p>{% img /images/smsbot/sms_app.png %}</p>

<p>Awesome-sauce üòé.</p>

<h2>Conclusions</h2>

<p><a href="https://github.com/openwhisk/openwhisk/blob/master/docs/webactions.md">OpenWhisk Web Actions</a> provide a convenient way to expose serverless functions as simple HTTP APIs. This feature is ideal for implementing webhook endpoints.</p>

<p>Both Slack and Twilio provide webhook integration for developers to use their platforms. Using OpenWhisk Web Actions, we can write serverless functions that act as a bridge between these services. With less than a hundred lines of code, we've created a new slack bot that can connect users to channels using SMS messages.</p>

<p>Pretty cool, huh?! üëèüëèüëè</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openwhisk and The Serverless Framework]]></title>
    <link href="http://jamesthom.as/blog/2017/02/09/openwhisk-and-the-serverless-framework/"/>
    <updated>2017-02-09T15:04:00+00:00</updated>
    <id>http://jamesthom.as/blog/2017/02/09/openwhisk-and-the-serverless-framework</id>
    <content type="html"><![CDATA[<p><a href="https://serverless.com">The Serverless Framework</a> is the most popular open-source framework for building serverless applications.</p>

<p><a href="https://serverless.com/blog/serverless-v1.6.0/">Recent releases</a> included support for using the framework with non-AWS providers. This feature makes it easier for developers to try different serverless platforms and move applications between providers.</p>

<p>Since last summer, I've been <a href="https://github.com/serverless/serverless-openwhisk">leading the technical effort</a> to provide an <a href="http://openwhisk.org/">OpenWhisk</a> provider plugin for the framework.</p>

<p>OpenWhisk is the first non-AWS serverless provider to complete integration into the framework.</p>

<p>{% img https://cloud.githubusercontent.com/assets/20538501/22434123/748ae372-e6e0-11e6-86d0-38db9941552d.png %}</p>

<h2>Getting Started</h2>

<p>Documentation for the provider plugin is available on <a href="https://serverless.com/framework/docs/">The Serverless Framework's website</a>.</p>

<p>Example projects using the framework to build applications for OpenWhisk are now available in <a href="https://github.com/serverless/examples">this repository</a>.</p>

<p>More details on the provider plugin can be found on the <a href="https://github.com/serverless/serverless-openwhisk">project repository</a>.</p>

<p>Found an issue? Feature request? Need help? Please <a href="https://github.com/serverless/serverless-openwhisk/issues">open issues on Github</a>.</p>

<h2>Video Demonstration</h2>

<iframe width="560" height="315" src="https://www.youtube.com/embed/GJY10W98Itc" frameborder="0" allowfullscreen></iframe>


<h2>Serverless Meetup Presentation</h2>

<p>Last week, I was invited to speak at the <a href="https://www.meetup.com/Serverless-London/events/236664340/">London's Serverless Meetup</a> about building multi-provider serverless applications using this feature.</p>

<p>Slides from the presentation are here:</p>

<script async class="speakerdeck-embed" data-id="592fbd47aceb4fbc9021ae3bf2f6b06c" data-ratio="1.77777777777778" src="http://jamesthom.as//speakerdeck.com/assets/embed.js"></script>


<p>There is a (low-fi) video recording from the event here:</p>

<iframe src="https://player.twitch.tv/?video=v119142073&autoplay=false" frameborder="0" allowfullscreen="true" scrolling="no" height="378" width="620"></iframe>


<p><a href="https://www.twitch.tv/serverlessldn?tt_medium=live_embed&tt_content=text_link" style="padding:2px 0px 4px; display:block; width:345px; font-weight:normal; font-size:10px; text-decoration:underline;">Watch live video from serverlessldn on www.twitch.tv</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenWhisk and Rust]]></title>
    <link href="http://jamesthom.as/blog/2017/01/18/openwhisk-and-rust/"/>
    <updated>2017-01-18T09:00:00+00:00</updated>
    <id>http://jamesthom.as/blog/2017/01/18/openwhisk-and-rust</id>
    <content type="html"><![CDATA[<p><em>This blog post is <a href="http://jamesthom.as/blog/2017/01/16/openwhisk-docker-actions/">one of</a> <a href="http://jamesthom.as/blog/2017/01/17/openwhisk-and-go/">a series</a> looking at using Docker Actions in OpenWhisk to support extra runtimes.</em></p>

<p>Let's look at writing serverless functions for <a href="http://openwhisk.org/">OpenWhisk</a> using <a href="https://rust-lang.org">Rust</a>.</p>

<p>{% blockquote %}
Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.
{% endblockquote %}</p>

<p>Rust has been growing in popularity since it launched in 2010. Rust is a popular language for writing microservices due to the focus on the attention to safety and strong concurrency support.</p>

<p>None of the major serverless platform natively support Rust at the moment. OpenWhisk does not include this as a default runtime. However, <a href="https://www.ibm.com/blogs/bluemix/2017/01/docker-bluemix-openwhisk/">recent updates</a> to OpenWhisk provide a path for writing serverless functions with Rust.</p>

<p>Let's re-write <a href="http://jamesthom.as/blog/2017/01/17/openwhisk-and-go/">the example</a> from the previous post in Rust and see how to get it running using this new approach‚Ä¶</p>

<p><strong><em>Have you seen <a href="http://jamesthom.as/blog/2017/01/16/openwhisk-docker-actions/">this post</a> explaining how Docker-based Actions work? This post assumes you have already read that first.</em></strong></p>

<h2>Rust Language Actions</h2>

<p>Rust has a <a href="http://doc.crates.io/guide.html">build system</a> that supports creating static binaries. These binaries contain the application source code and dependent libraries.</p>

<p>Using the same approach as the <a href="http://jamesthom.as/blog/2017/01/17/openwhisk-and-go/">Go-based example</a>, bundling this binary into a zip file allows us to overwrite the <a href="https://github.com/openwhisk/openwhisk/blob/master/core/actionProxy/stub.sh">runtime stub</a> prior to invocation.</p>

<p>Runtime binaries will be executed by the <a href="https://github.com/openwhisk/openwhisk/blob/master/core/actionProxy/actionproxy.py">Python-based invoker</a> for each invocation. Request parameters will be passed as a JSON string using the first command-line argument. The invoker expects the Action result to be written to standard output as a JSON string.</p>

<h3>Action Source Code</h3>

<p>Here's a simple Rust function that returns a greeting string from an input parameter. It parses the JSON string provided on the command-line to look for a <code>name</code> parameter. If this isn't present, it defaults to <code>stranger</code>. It returns a JSON object with the greeting string (<code>msg</code>) by writing to the console.</p>

<p>``` rust
extern crate rustc_serialize;
use rustc_serialize::json;
use rustc_serialize::json::Json;
use std::env;</p>

<h1>[derive(RustcDecodable, RustcEncodable)]</h1>

<p>pub struct Greeting {</p>

<pre><code>message: String
</code></pre>

<p>}</p>

<p>fn main() {</p>

<pre><code>let mut name = "stranger".to_string();

// first arg contains JSON parameters
if let Some(arg1) = env::args().nth(1) {
    // parse JSON and extract 'name' field
    let params = Json::from_str(&amp;arg1).unwrap();
    if let Some(params_obj) = params.as_object() {
        if let Some(params_name) = params_obj.get("name") {
            name = params_name.as_string().unwrap().to_string();
        }
    }
};

let greeting = Greeting {
    message: format!("Hello, {}!", name),
};

println!("{}", json::encode(&amp;greeting).unwrap());
</code></pre>

<p>}
```</p>

<h3>Set Up Project</h3>

<p>Using Rust's package management tool, create a new project for our serverless function.</p>

<p>Add the source code above into the <code>src/main.rs</code> file.</p>

<p>```sh
$ cargo new action; cd action</p>

<pre><code> Created library `action` project
</code></pre>

<p>$ mv src/lib.rs src/main.rs
$ vim src/main.rs
$ tree .
.
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src</p>

<pre><code>‚îî‚îÄ‚îÄ main.rs
</code></pre>

<p>1 directory, 2 files
```</p>

<p>This function uses the <code>rustc-serialize</code> crate to handle parsing and producing JSON.</p>

<p>Add this identifier to the project's dependencies listed in <code>Cargo.toml</code>.</p>

<p>``` sh
[package]
name = "action"
version = "0.1.0"
authors = ["Me <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x6d;&#101;&#x40;&#101;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#x6d;&#101;&#x40;&#x65;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;</a>"]</p>

<p>[dependencies]
rustc-serialize = "0.3"
```</p>

<p>Build and run the binary to test it works as expected.</p>

<p>```go
$ cargo run</p>

<pre><code>Updating registry `https://github.com/rust-lang/crates.io-index`
</code></pre>

<p>   Compiling rustc-serialize v0.3.22
   Compiling action v0.1.0 (file:///private/tmp/test/action)</p>

<pre><code>Finished debug [unoptimized + debuginfo] target(s) in 7.0 secs
 Running `target/debug/action`
</code></pre>

<p>{"message":"Hello, stranger!"}
$ cargo run '{"name": "James"}'</p>

<pre><code>Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs
 Running `target/debug/action {\"name\":\ \"James\"}`
</code></pre>

<p>{"message":"Hello, James!"}
```</p>

<p><em>Before we can deploy this binary to OpenWhisk, it must be compiled for the platform architecture.</em></p>

<h3>Cross-Compiling Locally</h3>

<p>Rust's compiler uses LLVM under the covers, making it possible to generate machine code for different architectures. Cross-compiling for different platforms requires having the correct compiler, linker and libraries for that architecture installed.</p>

<p>Rust <a href="https://blog.rust-lang.org/2016/05/13/rustup.html">recently released</a> a <a href="https://rustup.rs/">toolchain manager</a> to simplify this process.</p>

<p>Install the Rust toolchain for the <code>x86_64-unknown-linux-musl</code> runtime.</p>

<p><code>sh
$ rustup target add x86_64-unknown-linux-musl
info: downloading component 'rust-std' for 'x86_64-unknown-linux-musl'
info: installing component 'rust-std' for 'x86_64-unknown-linux-musl'
</code></p>

<p>Add the configuration file to set the correct linker for the runtime.</p>

<p><code>sh
$ cat .cargo/config
[target.x86_64-unknown-linux-musl]
linker = "x86_64-linux-musl-gcc"
</code></p>

<p>We can now cross-compile the binary for the correct environment.</p>

<p>``` sh
$ cargo build --target=x86_64-unknown-linux-musl --release
   Compiling rustc-serialize v0.3.22
   Compiling action v0.1.0 (file:///Users/james/code/bluemix/openwhisk-languages/rust/action)</p>

<pre><code>Finished release [optimized] target(s) in 9.30 secs
</code></pre>

<p>```</p>

<p>Checking the file type demonstrates we have built a static binary for the Linux x86_64 platform.</p>

<p><code>sh
$ file target/x86_64-unknown-linux-musl/release/action
target/x86_64-unknown-linux-musl/release/action: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, not stripped
</code></p>

<h3>Cross-Compiling Using Docker</h3>

<p>If you don't want to install the Rust development toolchain, Docker can be used to start a container with the <a href="https://github.com/emk/rust-musl-builder">environment set up</a>.</p>

<p>```sh
$ docker pull ekidd/rust-musl-builder
$ docker run -it -v $(pwd):/home/rust/src ekidd/rust-musl-builder cargo build --release</p>

<pre><code>Updating registry `https://github.com/rust-lang/crates.io-index`
</code></pre>

<p> Downloading rustc-serialize v0.3.22
   Compiling action v0.1.0 (file:///home/rust/src)</p>

<pre><code>Finished release [optimized] target(s) in 1.80 secs
</code></pre>

<p>$ file target/x86_64-unknown-linux-musl/release/action
target/x86_64-unknown-linux-musl/release/action: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, not stripped
```</p>

<h3>Create &amp; Deploy Archive</h3>

<p>Add the binary to a zip file, ensuring the file is named <code>exec</code> in the archive.</p>

<p>Use the <code>wsk</code> command-line to create a new Docker Action using this archive.</p>

<p><code>sh
$ cp target/x86_64-unknown-linux-musl/release/action exec
$ zip action.zip exec
  adding: exec (deflated 64%)
$ wsk action create rust_test action.zip --docker
ok: created action rust_test
</code></p>

<h3>Invoking Action</h3>

<p>Test the action from the command-line to verify it works.</p>

<p>```sh
$ wsk action invoke rust_test --blocking --result
{</p>

<pre><code>"msg": "Hello, Stranger!"
</code></pre>

<p>}
$ wsk action invoke rust_test --blocking --result --param name James
{</p>

<pre><code>"msg": "Hello, James!"
</code></pre>

<p>}
```</p>

<p>Success üòé.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openwhisk and Go]]></title>
    <link href="http://jamesthom.as/blog/2017/01/17/openwhisk-and-go/"/>
    <updated>2017-01-17T09:00:00+00:00</updated>
    <id>http://jamesthom.as/blog/2017/01/17/openwhisk-and-go</id>
    <content type="html"><![CDATA[<p><a href="http://jamesthom.as/blog/2016/06/21/serverless-go-actions/">In an earlier blog post</a>, I explained how to use Go language binaries on OpenWhisk using Docker-based Actions. It relied on building Docker images for each serverless function and hosting them on Docker Hub.</p>

<p><a href="https://www.ibm.com/blogs/bluemix/2017/01/docker-bluemix-openwhisk/">Recent updates</a>  to Docker-based Actions have made this process much simpler. Developers don't need to build and expose public images anymore.</p>

<p>Let's re-visit the example from the previous post and see how to get it running using this new approach‚Ä¶</p>

<p><strong><em>Have you seen <a href="http://jamesthom.as/blog/2017/01/16/openwhisk-docker-actions/">this post</a> explaining how Docker-based Actions work? This post assumes you have already read that first.</em></strong></p>

<h2>Go Language Actions</h2>

<p>Go's <a href="https://golang.org/pkg/go/build/">build system</a> combines application source code and dependencies into a single execution binary. Bundling this binary into a zip file allows us to overwrite the <a href="https://github.com/openwhisk/openwhisk/blob/master/core/actionProxy/stub.sh">runtime stub</a> prior to invocation.</p>

<p>Runtime binaries will be executed by the <a href="https://github.com/openwhisk/openwhisk/blob/master/core/actionProxy/actionproxy.py">Python-based invoker</a> for each invocation. Request parameters will be passed as a JSON string using the first command-line argument. The invoker expects the Action result to be written to standard output as a JSON string.</p>

<h3>Action Source Code</h3>

<p>Here's a simple Go function that returns a greeting string from an input parameter. It parses the JSON string provided on the command-line to look for a <code>name</code> parameter. If this isn't present, it defaults to <code>Stranger</code>. It returns a JSON object with the greeting string (<code>msg</code>) by writing to the console.</p>

<p>``` go
package main</p>

<p>import "encoding/json"
import "fmt"
import "os"</p>

<p>func main() {</p>

<pre><code>// native actions receive one argument, the JSON object as a string
arg := os.Args[1]

// unmarshal the string to a JSON object
var obj map[string]interface{}
json.Unmarshal([]byte(arg), &amp;obj)
name, ok := obj["name"].(string)
if !ok {
    name = "Stranger"
}
msg := map[string]string{"msg": ("Hello, " + name + "!")}
res, _ := json.Marshal(msg)
fmt.Println(string(res))
</code></pre>

<p>}
```</p>

<p>Building this locally allows us to test it works.</p>

<p><code>go
$ go run test.go '{"name": "James"}'
{"msg":"Hello, James!"}
</code></p>

<p><em>Before we can deploy this binary to OpenWhisk, it must be compiled for the platform architecture.</em></p>

<h3>Cross-Compiling Locally</h3>

<p>Go 1.5 <a href="https://dave.cheney.net/2015/08/22/cross-compilation-with-go-1-5">introduced much improved</a> support for cross-compilation.</p>

<p>If you have the development environment installed locally, you can compile the binary for another platform by setting environment variables. The full list of supported architectures is available <a href="https://golang.org/doc/install/source#environment">here</a>.</p>

<p><em>OpenWhisk uses an <a href="https://hub.docker.com/_/alpine/">Alpine Linux-based</a> environment to execute Actions.</em></p>

<p><code>sh
$ env GOOS=linux GOARCH=amd64 go build exec.go
</code></p>

<p>Checking the file type demonstrates we have built a static binary for the Linux x86_64 platform.</p>

<p><code>sh
$ file exec
exec: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped
</code></p>

<h3>Cross-Compiling Using Docker</h3>

<p>If you don't want to install the Go development toolchain, Docker can be used to start a container with the environment set up.</p>

<p><code>sh
$ docker pull golang
$ docker run -it -v $(pwd):/go/src golang
root@0a2f1655eece:/go# cd src/
root@0a2f1655eece:/go/src# go build exec.go
root@0a2f1655eece:/go/src# ls
exec  exec.go
$ file exec
exec: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped
</code></p>

<h3>Create &amp; Deploy Archive</h3>

<p>Add the binary to a zip file, ensuring the file is named <code>exec</code> in the archive.</p>

<p>Use the <code>wsk</code> command-line to create a new Docker Action using this archive.</p>

<p><code>sh
$ zip action.zip exec
  adding: exec (deflated 66%)
$ wsk action create go_test action.zip --docker
ok: created action go_test
</code></p>

<h3>Invoking Action</h3>

<p>Test the action from the command-line to verify it works.</p>

<p>```sh
$ wsk action invoke go_test --blocking --result
{</p>

<pre><code>"msg": "Hello, Stranger!"
</code></pre>

<p>}
$ wsk action invoke go_test --blocking --result --param name James
{</p>

<pre><code>"msg": "Hello, James!"
</code></pre>

<p>}
```</p>

<p>Success üòé.</p>
]]></content>
  </entry>
  
</feed>
