<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: openwhisk | James Thomas]]></title>
  <link href="http://jamesthom.as/blog/categories/openwhisk/atom.xml" rel="self"/>
  <link href="http://jamesthom.as/"/>
  <updated>2016-09-08T16:36:12+01:00</updated>
  <id>http://jamesthom.as/</id>
  <author>
    <name><![CDATA[James Thomas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Microservices Without Servers]]></title>
    <link href="http://jamesthom.as/blog/2016/09/08/microservices-without-servers/"/>
    <updated>2016-09-08T16:17:00+01:00</updated>
    <id>http://jamesthom.as/blog/2016/09/08/microservices-without-servers</id>
    <content type="html"><![CDATA[<p>‚Ä¶is the title of my presentation about building serverless applications using OpenWhisk.</p>

<script async class="speakerdeck-embed" data-id="387717983473473bb9eed49d50e6e279" data-ratio="1.77777777777778" src="http://jamesthom.as//speakerdeck.com/assets/embed.js"></script>


<h2>Abstract</h2>

<p><em>Servers are killing your productivity. Rather than building better software for your users, you end up constantly distracted by maintaining computers. Wasn't the "cloud" supposed to fix this? It sounded so promising until we realised it was just renting VMs in someone else's datacenter. We couldn't escape "servers". Until now...</em></p>

<p><em>In this session, developers will learn how to build microservices without servers, using modern ‚Äúserverless‚Äù cloud platforms. We‚Äôll look at common challenges (and solutions) to building applications using ‚Äúserverless‚Äù stacks. Exploring emerging ‚Äúserverless‚Äù design patterns will give developers the knowledge to build application architectures using these new platforms.</em></p>

<p><em>This session is aimed at software developers experienced in building traditional backend web applications, who want to learn how to build microservices without servers.</em></p>

<h2>Slides, Code, Videos</h2>

<p>Slides for the talk are available <a href="https://speakerdeck.com/jthomas/microservices-without-servers">here</a>.</p>

<p>There's a Github repository with resources <a href="https://github.com/jthomas/microservices_without_servers">from the talk</a>, including a <a href="https://github.com/jthomas/microservices_without_servers/blob/master/transcript.md">transcript</a>, <a href="https://github.com/jthomas/microservices_without_servers/blob/master/code">code demos</a> and <a href="https://www.youtube.com/playlist?list=PL0UyhC0D6KABYPvGroXcIeE-4x_yEbdB4">videos</a>.</p>

<p>If you have questions or issues, raise an issue in the repository or send me a <a href="https://twitter.com/thomasj">tweet</a>.</p>

<h2>Conference Sessions</h2>

<p>This talk was <a href="http://www.jday.com.ua/#nav-schedule">first delivered</a> at <a href="https://http://www.jday.com.ua/">JDayLviv</a> earlier this month. The session was recorded so the video should surface online soon. I'll be repeating the talk at <a href="https://belgrade.voxxeddays.com/talk/145/">VoxxedDays Belgrade</a> and <a href="http://javaday.org.ua/kyiv/#speakers">JavaDay Kiev</a> in September and October.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Serverless Go Actions]]></title>
    <link href="http://jamesthom.as/blog/2016/06/21/serverless-go-actions/"/>
    <updated>2016-06-21T17:01:00+01:00</updated>
    <id>http://jamesthom.as/blog/2016/06/21/serverless-go-actions</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/openwhisk/openwhisk">OpenWhisk</a>, the open-source serverless
platform, provides the ability to invoke custom
<a href="https://www.docker.com/">Docker</a> containers as serverless functions.</p>

<p>Developers can create new
<a href="https://github.com/openwhisk/openwhisk/blob/master/docs/actions.md">Actions</a>,
referencing public images on <a href="https://dockerhub.com">Dockerhub</a>. OpenWhisk
manages creating and executing containers using these images per invocation
request.</p>

<p>Using this feature, developers can write serverless functions using the
<a href="https://golang.org/">Go language</a>. Compiled Go language binaries are embedded
within custom Docker images and pushed into the platform.</p>

<p><strong>So, how do we start?</strong></p>

<p><em>This blog post will explain how to get your Go language functions running as
"serverless functions" on OpenWhisk. If you're impatient to get to the code,
this <a href="https://github.com/jthomas/openwhisk_go_action">repository</a> contains the
examples for everything discussed below.</em></p>

<p>OpenWhisk helps developers create custom Actions using Docker through an SDK...</p>

<h2>OpenWhisk Docker SDK</h2>

<p>Using the
<a href="https://new-console.ng.bluemix.net/docs/openwhisk/index.html"><em>wsk</em> command-line utility</a>,
developers can install the
<a href="https://github.com/openwhisk/openwhisk/tree/master/sdk/docker">SDK</a> into the
current directory.</p>

<p><code>
$ wsk sdk install docker
</code></p>

<p>The SDK provides the <a href="https://github.com/openwhisk/openwhisk/tree/master/sdk/docker">source for a custom Docker image</a>, which executes a custom
binary in response to invocation requests. The default SDK copies the
executable file, located at the <em>client/action</em>, into the image during the
build process. Users build the image locally before pushing this to Dockerhub.</p>

<p><code>sh
$ docker build -t &lt;dockerhub_user&gt;/docker_action .
$ docker push &lt;dockerhub_user&gt;/docker_action
</code></p>

<p>Using the command-line utility, users can then create a new Action referencing
this public Docker image. When this Action is invoked, the platform will spin
up a new container from this custom image.</p>

<p><code>sh
$ wsk action create docker_action --docker &lt;dockerhub_user&gt;/docker_action
$ wsk action invoke --blocking --result docker_action
</code></p>

<h2>OpenWhisk Docker Action </h2>

<p>OpenWhisk SDK's Docker image uses a Node.js
<a href="https://github.com/openwhisk/openwhisk/tree/master/sdk/docker/server">application</a>
to handle the JSON invocation request from the platform and spawns a process to
execute the binary. Invocation parameters are passed as a JSON string through a
command-line argument to the binary. The executable must write the JSON
response to stdout, the handler will return this to the platform.</p>

<p>Containers used to run OpenWhisk Actions must be expose a HTTP API on port 8080
with two paths, <em>/init</em> and <em>/run</em>. The platform sends HTTP POST requests to
these paths to initialise the Action and schedule invocations.</p>

<p>The <em>/init</em> path is used to provide the Action source for languages which
support runtime evaluation. <strong>User-provided Docker images do not need to
implement this method, other than returning a non-error HTTP response.</strong></p>

<p>The <em>/run</em> path is called by the platform for each invocation request.
Parameters for the invocation are passed as the <em>value</em> property of the JSON
request body. Any non-empty JSON response will be interpreted as the invocation
result.</p>

<h2>Go Actions using the Docker SDK</h2>

<p>Using Go binaries with the Docker SDK requires the developer to cross-compile
the source for the platform architecture and copy the binary to the
<em>client/action</em> path.</p>

<p><code>
export GOARCH=386
export GOOS=linux
go build -o action
mv action client/action
</code></p>

<p>The Go code must parse the invocation parameters as a JSON string from the
command-line argument. Data written to <em>stdout</em> will be parsed as JSON and
returned as the Action response.</p>

<p>This sample Go source demonstrates using this method to implement a "reverse
string" Action.</p>

<p>``` go
package main</p>

<p>import "os"
import "encoding/json"
import "log"</p>

<p>type Params struct {
  Payload string <code>json:"payload"</code>
}</p>

<p>type Result struct {
  Reversed string <code>json:"reversed"</code>
}</p>

<p>// extract invocation parameters, passed as JSON string argument on command-line.
func params() Params {
  var params Params
  source := os.Args[1]
  buf := []byte(source)
  if err := json.Unmarshal(buf, &amp;params); err != nil {</p>

<pre><code>log.Fatal(err)
</code></pre>

<p>  }
  return params
}</p>

<p>// convert struct back to JSON for response
func return_result(result Result) {
  buf, err := json.Marshal(result)
  if err != nil {</p>

<pre><code>log.Fatal(err)
</code></pre>

<p>  }
  os.Stdout.Write(buf)
}</p>

<p>func main() {
  input := params()</p>

<p>  // reverse the string passed from invocation parameters
  chars := []rune(input.Payload)
  for i, j := 0, len(chars)-1; i &lt; j; i, j = i+1, j-1 {</p>

<pre><code>chars[i], chars[j] = chars[j], chars[i]
</code></pre>

<p>  }
  result := Result{</p>

<pre><code>Reversed: string(chars),
</code></pre>

<p>  }</p>

<p>  return_result(result)
}
```</p>

<h2>Docker SDK Base Image</h2>

<p>Building a base image from the OpenWhisk Docker SDK and publishing on Dockerhub
simplifies the process of building a Docker-based Action. Developers can now
use the following image
(<a href="https://hub.docker.com/r/jamesthomas/openwhisk_docker_action/">jamesthomas/openwhisk_docker_action</a>),
without having to install the SDK locally.</p>

<p><code>
FROM jamesthomas/openwhisk_docker_action
COPY action /blackbox/action
</code></p>

<p>This base image includes the Node.js handler to manage the platform HTTP
requests. An executable file at <em>/blackbox/action</em> will be called for each
invocation. JSON parameters and responses are still passed using command-line
arguments and stdout.</p>

<h2>Custom Go Handler </h2>

<p>Using the Docker SDK for OpenWhisk relies on a Node.js application to handle
the platform HTTP requests, spawning a process to execute the user binary file.</p>

<p>Implementing the HTTP API, described above, in Go would allow us to remove the
Node.js handler from the image. Compiling the Go Action source with the HTTP
API handler into a single binary and using an Alpine Linux base image will
dramatically reduce the image size.</p>

<p>This should improve execution performance, by removing the Node.js VM process,
and cold start-up time, through having a smaller Docker image.</p>

<p><strong>Using this Go package, <a href="https://github.com/jthomas/ow">jthomas/ow</a>, users can
automate the process of creating Go-based Actions.</strong></p>

<p><code>
go get jthomas/ow
</code></p>

<p><em>The package provides a method for registering Action callbacks and implements
the HTTP endpoints for handling platform requests.</em></p>

<p><em>Invocation parameters are passed using a function parameter, rather than a raw
JSON string. Returned interface values will be automatically serialised to JSON
as the Action response.</em></p>

<p><code>go
openwhisk.RegisterAction(func(value json.RawMessage) (interface{}, error) {
   ...  
}
</code></p>

<p>Re-writing the "reverse string" Action above to use this package is shown here.</p>

<p>``` go
package main</p>

<p>import (</p>

<pre><code>"encoding/json"
"github.com/jthomas/ow"
</code></pre>

<p>)</p>

<p>type Params struct {</p>

<pre><code>Payload string `json:"payload"`
</code></pre>

<p>}</p>

<p>type Result struct {</p>

<pre><code>Reversed string `json:"reversed"`
</code></pre>

<p>}</p>

<p>func reverse_string(to_reverse string) string {</p>

<pre><code>chars := []rune(to_reverse)
for i, j := 0, len(chars)-1; i &lt; j; i, j = i+1, j-1 {
    chars[i], chars[j] = chars[j], chars[i]
}
return string(chars)
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code>ow.RegisterAction(func(value json.RawMessage) (interface{}, error) {
    var params Params
    err := json.Unmarshal(value, &amp;params)
    if err != nil {
        return nil, err
    }
    return Result{Reversed: reverse_string(params.Payload)}, nil
})
</code></pre>

<p>}
```</p>

<p>Cross-compiling the Action source, bundling this package, creates a single
lightweight binary.</p>

<p>Embedding this file within a Docker image, using a minimal base image, creates
a tiny image (&lt;10MB). Containers from these images only execute a single
process to handle both the HTTP requests and running the Action source.</p>

<p><code>
FROM alpine:3.4
COPY action /action
EXPOSE 8080
CMD ["./action"]
</code></p>

<p>Pushing the local image to Dockerhub and then using it to create an Action
follows the same instructions above.</p>

<h2>Conclusion</h2>

<p>Running OpenWhisk Actions from user-provided Docker images allows developers to
execute "serverless functions" using any language. This is a fantastic feature
not currently supported by many of the other serverless providers.</p>

<p>OpenWhisk provides an
<a href="https://github.com/openwhisk/openwhisk/tree/master/sdk/docker">SDK</a> letting
users build a local Docker image which executes their Action and handles the
HTTP requests from the platform. Using this with <a href="https://github.com/jthomas/openwhisk_go_action/tree/master/docker_sdk">Go-based Actions</a> requires us
to cross-compile our binary for the platform and handle passing JSON through
command-line arguments and stdout.</p>

<p>Re-writing the HTTP handler <a href="https://github.com/jthomas/openwhisk_go_action/tree/master/go_handler">natively in Go</a>
means the Docker image can contain and execute a single binary for both tasks.
Using this <a href="https://github.com/jthomas/ow">Go package</a> provides an interface for registering Actions and handles
the HTTP requests automatically.</p>

<p><strong>This <a href="https://github.com/jthomas/openwhisk_go_action">project</a> contains
examples for the "reverse string" Action using both the Docker SDK and Go-based
handler detailed above.</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenWhisk and MQTT]]></title>
    <link href="http://jamesthom.as/blog/2016/06/15/openwhisk-and-mqtt/"/>
    <updated>2016-06-15T15:35:00+01:00</updated>
    <id>http://jamesthom.as/blog/2016/06/15/openwhisk-and-mqtt</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/openwhisk/openwhisk/blob/master/docs/packages.md#creating-and-using-trigger-feeds">OpenWhisk Feeds</a>
provide the mechanism to bind external events sources to serverless function
executions.</p>

<p><em><strong>Want to use OpenWhisk to listen for database updates to generate usage
statistics? Or write Slack bots that respond to trigger words? Or notify users
when Github project changes?</strong></em></p>

<p>Rather than manually listening for these events with an external application
and calling OpenWhisk <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/actions.md">Actions</a>
through the API, OpenWhisk Feeds automate connecting external events sources with Actions.</p>

<p>Feeds allow users to register
<a href="https://github.com/openwhisk/openwhisk/blob/master/docs/triggers_rules.md">Triggers</a>
to be invoked when external events occur. Defining
<a href="https://github.com/openwhisk/openwhisk/blob/master/docs/triggers_rules.md">Rules</a>
that bind these Triggers to Actions, we can have Actions run for external events.</p>

<p><img src="https://raw.githubusercontent.com/openwhisk/openwhisk/master/docs/OpenWhisk.png"></p>

<h2>OpenWhisk Packages </h2>

<p>Feeds are contained within and accessible through <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/packages.md">Packages</a>.</p>

<p>OpenWhisk provides numerous built-in packages under the <em>whisk.system</em> namespace.
These packages contain both public Actions and Feeds.</p>

<p><code>sh
$ wsk package list /whisk.system
packages
/whisk.system/alarms                                              shared
/whisk.system/cloudant                                            shared
/whisk.system/watson                                              shared
/whisk.system/system                                              shared
/whisk.system/weather                                             shared
/whisk.system/util                                                shared
/whisk.system/slack                                               shared
/whisk.system/samples                                             shared
/whisk.system/github
</code></p>

<p>Retrieving the package summary, the Actions and Feeds contained within are
returned. Feeds are referenced by the publisher's namespace, package and feed name, e.g.
<em>/whisk.system/alarms/alarm</em></p>

<p><code>sh
$ wsk package get /whisk.system/alarms --summary
package /whisk.system/alarms: Alarms and periodic utility
   (params: cron trigger_payload)
 feed   /whisk.system/alarms/alarm: Fire trigger when alarm occurs
</code></p>

<p>The Alarm package (<em>/whisk.system/alarms</em>) contains a single Feed
(<em>/whisk.system/alarms/alarm</em>) that calls the registered Trigger on a fixed
schedule. Users provide the timer schedule through the cron parameter.</p>

<p>When creating new Triggers, users can specify a Feed source to bind their new
Trigger to the external event source. Parameters from the command-line will be
passed to the Feed source. The Feed provider will execute the Trigger each time
an external event occurs.</p>

<p><code>sh
$ wsk trigger create everySecond --feed /whisk.system/alarms/alarm -p cron '*/1 * * * * *' -p trigger_payload '{"vote":"Bernie"}'
</code></p>

<p>This new Trigger will be invoked every second with the payload contents by the
alarm Feed. Using rules, the Feed Trigger can be bound to call an Action on
each invocation.</p>

<p><code>sh
$ wsk rule create --enable alarmRule everySecond actionName
</code></p>

<p><em>As well as using the built-in Feeds, users can create and register custom
Feeds. This provides a way to integrate almost any external event source into
the platform. Publishing custom Feeds within a public package will also make
this event source available to all users on the systen, provided they know the
package identifier.</em></p>

<h2>Creating Custom Feeds</h2>

<p>Users register new Feeds by providing a custom Action to the platform. This
Action is invoked each time the Feed is bound to a new Trigger. Authentication
credentials, supporting Trigger invocation through the OpenWhisk API, are
passed in as invocation parameters.</p>

<p>This sample Action contains an outline for processing requests.</p>

<p>``` javascript Feed Action
// params.lifeCycleEvent - Enum value (CREATE|DELETE)
// params.triggerName - User's Trigger identifier to call
// params.authKey - Authentication details for calling Trigger</p>

<p>function main (params) {
  if (params.lifecycleEvent === 'CREATE') {</p>

<pre><code>create(params);
</code></pre>

<p>  } else if (params.lifecycleEvent === 'DELETE') {</p>

<pre><code>remove(params)
</code></pre>

<p>  }</p>

<p>  return whisk.async();
}
```</p>

<p>The <em>params</em> argument contains the Trigger information provided by the
platform and any parameters from the user during creation.</p>

<p>The <em>lifeCycleEvent</em> parameter is a string value, informing the Feed provider
whether to register (CREATE) or remove (DELETE) the user's Trigger with the
event source.  The Trigger identifier is passed as the <em>triggerName</em> parameter,
with the authentication key (<em>authKey</em>) used for the API requests.</p>

<p>Feed Actions must be registered with a custom annotation (<em>feed</em>), allowing the
platform to distinguish them from "normal" Actions. This annotation can be set
during the create command.</p>

<p><code>sh
$ wsk action create -a feed true feed_name feed_action.js
</code></p>

<p>Once a custom Feed Action has been registered, users can create new Triggers
using that Feed source, following the steps above.</p>

<h2>MQTT Feeds</h2>

<p>The <a href="https://en.wikipedia.org/wiki/Internet_of_things">"Internet of Things"</a>
is often cited as a common usecase for serverless
platforms. Solutions are often event-driven and stateless, e.g. wait for data
from this device, do some processing and then store the results in this
database.</p>

<p><a href="https://en.wikipedia.org/wiki/MQTT">MQTT</a> is a lightweight publish-subscribe
messaging protocol, commonly used for edge of network device-to-device
communication.</p>

<p>Bridging MQTT messages to OpenWhisk Actions can be achieved by creating a new
Feed provider. This provider would subscribe to message topics and execute
registered Triggers with incoming messages.</p>

<p>The <a href="https://github.com/jthomas/openwhisk_mqtt_feed/tree/master/provider">custom feed provider</a>
would need to establish and maintain long-lived MQTT
connections, waiting for messages to arrive. This requirements means the Feed
provider needs an external service to handle managing these connections, it
won't be possible within the Feed Action.</p>

<p>This <a href="https://github.com/jthomas/openwhisk_mqtt_feed">feed provider service</a> is implemented using Node.js, using Cloudant for the
database. The service listens for HTTP requests, with Trigger registration
details, from the <a href="https://github.com/jthomas/openwhisk_mqtt_feed/blob/master/provider/index.js">Feed Action</a>.
The Node.js <a href="https://www.npmjs.com/package/mqtt">MQTT library</a> is used to subscribe to
registered topics. When messages are received, the <a href="https://www.npmjs.com/package/openwhisk">OpenWhisk client library</a> is
used to invoke the Trigger remotely, passing the message contents as event parameters.</p>

<p>This service provider is <a href="https://github.com/jthomas/openwhisk_mqtt_feed/blob/master/provider/Dockerfile">packaged using Docker</a>.</p>

<p>Pushing this image into the <a href="https://console.ng.bluemix.net/docs/containers/container_index.html">IBM Containers registry</a>,
the Feed provider can be started on IBM Bluemix using the Containers service.</p>

<p><code>sh Pushing feed provider to IBM Containers
$ docker build -t USERNAME/mqtt_feed_provider .
$ docker tag USERNAME/mqtt_feed_provider registry.ng.bluemix.net/USERNAME/mqtt_feed_provider
$ docker push registry.ng.bluemix.net/USERNAME/mqtt_feed_provider
</code></p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/create_container.png"></p>

<h2>Registering Feeds</h2>

<p>With the Feed service provider running, the Feed Action can be deployed.</p>

<p>The Feed will be registered under the name, <em>mqtt_feed_provider</em>, in a custom
package, mqtt.</p>

<p>Using the <em>--shared</em> command-line flag, the Feed package can be registered as a
public package. Feeds and Actions within public packages are visible to every
system user.</p>

<p>Rather than hardcoding the service provider location within the Feed Action,
this configuration value will be accessible as a package parameter. This can be
updated at runtime with modifying the Feed Action source.</p>

<p><code>sh
$ wsk package create --shared -p provider_endpoint "http://CONTAINER_IP:3000/mqtt" mqtt
$ wsk package update mqtt -a description 'MQTT topic feed. Messages received on broker topic as passed to triggers"
</code></p>

<p>Having created the package, we can add the Feed Action, using the custom
attribute to denote this is a Feed Action.</p>

<p><code>sh
$ wsk action create -a feed true mqtt/mqtt_feed mqtt_feed.js
</code></p>

<p>Once the Feed has been registered, it can be referenced when creating new Triggers.</p>

<p><code>sh
$ wsk trigger create feed_trigger --feed /james.thomas@uk.ibm.com_dev/mqtt/mqtt_feed -p topic 'whiskers' -p url 'mqtt://test.mosca.io'
</code></p>

<p>MQTT broker url and topic name are passed as Trigger parameters, using the -p
flags. These values are included within the invocation arguments to the Feed
Action, shown below.</p>

<p><code>javascript
var params = {
  authKey: 'USERNAME:PASSWORD',
  url: 'mqtt://test.mosca.io',
  provider_endpoint: 'http://CONTAINER_IP:3000/mqtt',
  topic: 'whiskers',
  lifecycleEvent: 'CREATE',
  triggerName: '/james.thomas@uk.ibm.com_dev/feed_trigger'
}
</code></p>

<p>Once the Feed service provider has connected to the broker and subscribed to
the topic, incoming messages will register as Trigger events invocations for
the public_feed Trigger.</p>

<p>Using this custom Feed, users can easily connect MQTT messages to OpenWhisk Actions.</p>

<h2>Github Project</h2>

<p>Source code for this custom OpenWhisk Feed is available <a href="https://github.com/jthomas/openwhisk_mqtt_feed">here</a>.
The project contains the <a href="https://github.com/jthomas/openwhisk_mqtt_feed/blob/master/feed_action.js">Feed Action</a>
and <a href="https://github.com/jthomas/openwhisk_mqtt_feed/tree/master/provider">Provider service</a>.
The <a href="https://github.com/jthomas/openwhisk_mqtt_feed/blob/master/README.md">README</a> contains the deployment and usage instructions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Serverless APIs with OpenWhisk and API Connect]]></title>
    <link href="http://jamesthom.as/blog/2016/04/26/serverless-apis-with-openwhisk-and-api-connect/"/>
    <updated>2016-04-26T07:54:00+01:00</updated>
    <id>http://jamesthom.as/blog/2016/04/26/serverless-apis-with-openwhisk-and-api-connect</id>
    <content type="html"><![CDATA[<p>"Serverless" cloud platforms are a
<a href="http://redmonk.com/fryan/2016/04/28/serverless-volume-compute-for-a-new-generation/">major trend in 2016</a>.
Following on from Amazon's <a href="https://aws.amazon.com/lambda/">Lambda service</a>,
released eighteen months ago, this year has seen <a href="https://developer.ibm.com/openwhisk/">IBM</a>,
<a href="https://azure.microsoft.com/en-us/documentation/articles/functions-reference/">Microsoft</a>
and <a href="https://cloud.google.com/functions/">Google</a> all launch their own solutions.</p>

<p>These platforms let you build stateless <a href="http://martinfowler.com/articles/microservices.html">microservices</a>,
combining APIs with
business logic, without servers. Microservices are executed on-demand, in
milliseconds, rather than having to sit idle waiting for incoming requests.
Users pay only for the raw computation time used.</p>

<p>Combining serverless APIs with static file hosting for site resources, e.g.
HTML, JavaScript and CSS, means we can build entire <a href="https://blog.hartleybrody.com/serverless-stack/">serverless web applications</a>.</p>

<p>Playing with OpenWhisk recently to build simple microservices, I began to
investigate using the platform to build the APIs for serverless applications.</p>

<p><strong>How can we use OpenWhisk to define a new microservice and then expose that
service as an API with a HTTP interface?</strong></p>

<p><em>Let's start by looking at OpenWhisk...</em></p>

<h2>OpenWhisk</h2>

<p>Using the OpenWhisk platform, developers register small bits of code, known as
<a href="https://github.com/openwhisk/openwhisk/blob/master/docs/actions.md"><em>Actions</em></a>,
that can be invoked on-demand. These functions can be written in
Node.js, Swift or Docker images. Let's look at a simple Node.js Action that
takes a parameter and returns a message with that value.</p>

<p>``` javascript OpenWhisk Action
function main(params) {
  return {</p>

<pre><code>payload: 'Hello ' + params.name
</code></pre>

<p>  };
}
```</p>

<p><a href="https://github.com/openwhisk/openwhisk/blob/master/docs/actions.md#creating-and-invoking-a-simple-javascript-action">Node.js actions</a> must include a function named <em>main</em>. OpenWhisk executes
this function for each invocation, passing request parameters as arguments.
Return values from the function will be included in the response.</p>

<p>Using the OpenWhisk <a href="https://new-console.ng.bluemix.net/openwhisk/cli">command-line utility</a>,
we turn this local JavaScript code into a remote action.</p>

<p><code>sh
[~/code/serverless]$ ls
source.js
[~/code/serverless]$ wsk action create hello_action source.js
ok: created action hello_action
[~/code/serverless]$ wsk action list
actions
/james.thomas@uk.ibm.com_dev/hello_action                         private
</code></p>

<p>With the action registered, we can test the service from the command-line.</p>

<p>``` sh
[~/code/serverless]$ wsk action invoke -b hello_action -p name "Bernie Sanders"
ok: invoked hello_action with id 429b35c3e3ac494ea902390ca64afe32
response:
{</p>

<pre><code>"result": {
    "payload": "Hello Bernie Sanders"
},
"status": "success",
"success": true
</code></pre>

<p>}
```</p>

<p>We can also update the action to use default parameter values.</p>

<p>``` sh
[~/code/serverless]$ wsk action update hello_action -p name "Donald Trump"
ok: updated action hello_action
[~/code/serverless]$ wsk action invoke -b hello_action
ok: invoked hello_action with id 0299bf2baf9242b7a00a8095caaeb7a4
response:
{</p>

<pre><code>"result": {
    "payload": "Hello Donald Trump"
},
"status": "success",
"success": true
</code></pre>

<p>}
[~/code/serverless]$
```</p>

<p>Registered actions can be executed manually, using an authenticated API
request, or automatically, hooking actions to triggers and feeds using rules.
For more details on triggers, feeds and rules, please see the <a href="https://github.com/openwhisk/openwhisk/tree/master/docs">OpenWhisk documentation</a>.</p>

<p>The command-line utility translates commands into HTTP requests to
the OpenWhisk API.</p>

<p><em>Pro-Tip: Adding the '-v' flag when using command-line utility will show HTTP
traffic sent to the OpenWhisk API.</em></p>

<h2>Serverless APIs With OpenWhisk</h2>

<p>Building backend services for serverless web applications, there were two
challenges to resolve before invoking these APIs from client-side JavaScript code.</p>

<ul>
<li><p><strong>Authentication.</strong> <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/reference.md#rest-api">OpenWhisk API</a>
requests require HTTP authentication, using the
developer's credentials. Embedding these credentials within client-side files
is a terrible idea...</p></li>
<li><p><strong>Cross-Domain Requests.</strong> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">CORS support</a>
is not enabled on the OpenWhisk platform.
Calling services from a browser would mandate us having CNAME records
configured with an external domain.</p></li>
</ul>


<p>Authentication needs to be resolved, while cross-domain support is an inconvenience.</p>

<p>Using OpenWhisk on IBM Bluemix, we have access to a huge range of cloud
services to help build applications. Reviewing the catalogue, there's a new
service <a href="https://developer.ibm.com/apiconnect/">API Connect</a> which can help us
resolve both issues with minimal effort.</p>

<h2>API Connect</h2>

<p>Announced in February, <a href="https://developer.ibm.com/apiconnect/">API Connect</a> is IBM's new "API Management-as-a-Service"
solution. Developers can use the service for creating, running, managing and
securing APIs in the cloud.</p>

<p><em>Using this service, we can construct new public APIs, with CORS support, that
proxy the authenticated OpenWhisk APIs used to trigger our services. Using these
APIs from our serverless frontends will be possible without leaking
credentials or having to configure DNS records.</em></p>

<p>Once we've signed up for an account with API Connect, you need to install the
developer toolbox locally. Using this tool will allow us to construct new APIs and
publish them to the cloud.</p>

<p><strong><em>TLDR: I've exported the sample flow configuration generated below
<a href="https://gist.github.com/jthomas/5136d53028e53d0e3ab86cfc3fc29869">here</a>.
Import this YAML file into the API Connect editor, replacing USERNAME, PASSWORD
and NAMESPACE, before deploying this flow to IBM Bluemix.</em></strong></p>

<h2>API Editor</h2>

<p>Install the API Connect <a href="https://www.npmjs.com/package/apiconnect">Toolkit using NPM</a> and run the following command to open
the editor.</p>

<p><code>sh
$ npm install -g apiconnect
$ apic edit
</code></p>

<p>Using the APIs panel, select the <em>Add</em> button. Provide a title for your
service.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/API%20Wizard.png"></p>

<p>Leave the <em>Add to a new product</em> checkbox selected and provide a
title for the product.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/API_Add.png"></p>

<p>The editor now shows the Design panel, allowing you to define the external
public API schema.</p>

<p>We're going to define a single endpoint (<em>/hello-name</em>) which supports HTTP GET
requests with a single query parameter.</p>

<h2>Adding the endpoint</h2>

<p><em>Disable the clientID definition under the "Security" panel and then scroll down
to the Paths section.</em></p>

<p>Add a new path for the endpoint <em>/hello-name</em>. Set a parameter for this path,
using the identifier <em>name</em> from location as <em>query</em> and type as <em>string</em>.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/paths.png"></p>

<p>Move to the <em>Definitions</em> section to define the API response schema. We
want to return a JSON object with a single property, result, that contains the
JSON object returned from the Action response.</p>

<p>Add a new Definition, named <em>whisk_response</em> and type as <em>object</em>, with a
single object property, <em>result</em>.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/definitions.png"></p>

<p>Under the Paths panel, expand the GET operation.
Set the schema for the 200 response to <em>whisk_response</em>.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/path_response.png"></p>

<p>CORS supported is already enabled by default (under the Lifecycle section).
Click the <em>Save</em> icon in toolbar and then move to the "Assemble" tab.</p>

<h2>Defining API operations</h2>

<p>Having defined the public API schema, we need to implement the API operations.</p>

<p>On the "Assemble" tab, the flow editor allows us to connect different backend
operations to construct our service. IBM Bluemix only supports deploying flows
constructed with the "DataPower Gateway policies" nodes. Microgateway nodes,
e.g. Javascript, are not supported.</p>

<h2>Invoking OpenWhisk Actions</h2>

<p>The default flow contains a single invoke node. This node type makes HTTP
requests, passing the result to the next node in the flow.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/invoke.png"></p>

<p>Use this node to execute your OpenWhisk Action by bringing up the editor and changing the URL to the correct endpoint, e.g.
<em>https://openwhisk.ng.bluemix.net/api/v1/namespaces/YOUR_NAMESPACE/actions/ACTION_ID?blocking=true</em></p>

<p>Make sure to include the query parameter, <em>blocking=true</em>. This makes OpenWhisk
wait until the Action has completed execution before returning, rather than
after invocation starts.</p>

<p>Change the HTTP method from GET to POST and fill in the username and passwords fields.</p>

<p>Add the value <em>invoke_result</em> to the <em>Response Object Variable</em> field. This
will save the HTTP response into a context variable we can reference in the
following map node definition.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/invoke_details.png"></p>

<h2>Passing Query Parameters</h2>

<p>Invoking OpenWhisk Actions through the API uses a HTTP POST request, passing
parameters within the JSON body. Our external API supports HTTP GET
operations, with parameters through query string values in the URL.</p>

<p>Using the <em>map</em> node in the flow will translate between these two methods.</p>

<p>Drag a <em>map</em> node from the left-hand panel and drop it on the wire between the
circle and the invoke node.</p>

<p>Open the map node editor and add a new <em>input</em> parameter.
Change the context variable to <em>request.parameters.name</em> with type <em>string</em>.
This contains the query parameter value we're using to pass in action arguments.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/query_parameter_source.png"></p>

<p>Returning to the map node editor, add a new <em>output</em> parameter. Leave the
Context variable as <em>message.body</em>. This variable will be used by the invoke
node to populate the request body.</p>

<p>Change the Content Type to <em>application/json</em>.
Select the definition as <em>inline schema</em> to define the JSON schema for the HTTP POST body.
Add the following JSON Schema definition to the editor form.</p>

<p>``` javascript JSON Schema
{
  "properties": {</p>

<pre><code>"name": {
  "type": "string"
}
</code></pre>

<p>  },
  "type": "object"
}
```</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/query_parameter_output.png"></p>

<p>With the input and output formats defined, we can wire the two parameters together.
Under the <em>Map</em> panel, click the dot next to the input parameter and then click the second dot on the right, next to the <em>name:string</em> label.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/query_parameter.png"></p>

<p>Remember to click <em>Save</em> before proceeding.</p>

<h2>Returning Action Result</h2>

<p>OpenWhisk Action API invocation responses include both the action result
payload and meta-data about the invocation event.</p>

<p>``` javascript Sample Invocation Event
{
  "name": "hello_action",
  "subject": "james.thomas@uk.ibm.com",
  "activationId": "5388b29e9f134737baf57bd12257dfd7",
  "publish": false,
  "annotations": [],
  "version": "0.0.1",
  "response": {</p>

<pre><code>"result": {
  "payload": "Hello Bernie"
},
"success": true,
"status": "success"
</code></pre>

<p>  },
  "end": 1461667635975,
  "logs": [],
  "start": 1461667635970,
  "namespace": "james.thomas@uk.ibm.com"
}
```</p>

<p>Rather than returning the raw result, we only want to return the result payload
property (<em>response.result</em>). Using another <em>map</em> node we can define a subset
of the invoked API response to be the HTTP response body.</p>

<p>Add a second <em>map</em> node to the flow, this time after the <em>invoke</em> node.</p>

<p>Add a new <em>input</em> property. We previously set a
context variable in the invoke definition that will contain the API response
(<em>invoke_api</em>). The response body is available as the <em>body</em> property of this
variable.</p>

<p>Edit the <em>context variable</em> to be <em>invoke_api.body.response.result</em> to set the
input property as the child property of the invoke result. Set the <em>content
type</em> to <em>application/json</em> and schema to <em>object</em>.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/map_response_source.png"></p>

<p>Add a new <em>output</em> property. Leave the context variable as <em>message.body</em>.
This context variable is used as the response body.</p>

<p>Set <em>content type</em> to <em>application/json</em> and change the definition to <em>#/definitions/whisk_response</em>.
This was the JSON schema we created during the external API definition.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/map_response_output.png"></p>

<p>Returning to the map overview, wire together the input property to the result
attribute of the output property.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/map_response.png"></p>

<p>Click the <em>Save</em> icon before making any further changes.</p>

<p>Using the invoke and map nodes, we've now implemented our external API.
Making our API live requires us to deploy the flow definition to IBM Bluemix.</p>

<h2>Deploying to IBM Bluemix</h2>

<p>After saving your flow, click the <em>Publish</em> icon in the top-right hand corner.
We're going to publish to the default <em>Sandbox</em> target. Follow the steps to
find and add this target to the local editor.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/publish.png"></p>

<p>Once you've added <em>Sandbox</em> as the default
target, select <em>Publish</em> and click the configured catalogue. On the dialog box,
select the <em>Select Specific Products</em> option and choose the <em>openwhisk</em>
product.</p>

<p>Clicking the confirmation button will upload our API definition to
the external API Connect platform.</p>

<p>If everything has been configured and deploying correctly, your new API should
now be live!</p>

<p>Let's test it...</p>

<h2>Testing </h2>

<p>Opening the <a href="https://new-console.ng.bluemix.net/apis/apiconnect">API Connect dashboard</a>,
the sandbox catalogue should now contain the <em>openwhisk</em> product with the public API we defined using the editor.</p>

<p><img src="https://dl.dropboxusercontent.com/u/10404736/openwhisk_apis/catalogue.png"></p>

<p>We can now verify this API works by making the HTTP request to the endpoint.
Under the <em>Settings</em> tab, the <em>API Endpoint</em> section contains the <em>Base URL</em>
for our API catalogue. APIs deployed under this catalogue will use this
path as the endpoint root.</p>

<p>The API definition registered a relative URL path, <em>/hello-name</em>, which
we can combine with the catalogue endpoint (e.g.
<em>https://api.us.apiconnect.ibmcloud.com/USER_ORG_SPACE/sb</em>) to generate an
public API endpoint.</p>

<p>We can now test this API by sending a HTTP GET request to the URL, passing the
name as a query parameter.</p>

<p>``` sh
[17:13:10 ~]$ http get https://api.us.apiconnect.ibmcloud.com/jamesthomasukibmcom-dev2/sb/hello-name?name="Bernie Sanders"
HTTP/1.1 200 OK
Content-Encoding: gzip
Content-Type: application/json
Date: Tue, 26 Apr 2016 16:24:36 GMT</p>

<p>{</p>

<pre><code>"result": {
    "payload": "Hello Bernie Sanders"
}
</code></pre>

<p>}</p>

<p>[17:24:36 ~]$
```</p>

<p>It works! üòÉ</p>

<p>We've successfully used API Connect to create an external API which proxies the
OpenWhisk API. We now have a public endpoint we can use to invoke OpenWhisk
Actions, without exposing our credentials and enabling CORS-support for
cross-domain XHRs.</p>

<h2>Conclusion</h2>

<p>Serverless computing platforms give developers a rapid way to build APIs
without servers. Combining this approach for building backend services with
static file hosting provides an architecture for developing entire serverless
web applications.</p>

<p>Experimenting with OpenWhisk as the backend platform for building serverless
web applications, there were two challenges, authentication and cross-domain
support.</p>

<p>Both issues were resolved using the API Connect service on IBM Bluemix.</p>

<p>API Connect is an incredibly powerful tool for creating, running, managing and
securing APIs. Using the editor application to construct a new API, the
endpoint was implemented using the invoke and map nodes. Deploying the
generated flow to IBM Bluemix exposed the API as a public endpoint.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Playing With OpenWhisk]]></title>
    <link href="http://jamesthom.as/blog/2016/04/22/openwhisk/"/>
    <updated>2016-04-22T15:36:00+01:00</updated>
    <id>http://jamesthom.as/blog/2016/04/22/openwhisk</id>
    <content type="html"><![CDATA[<p>IBM recently launched <a href="https://developer.ibm.com/openwhisk/">OpenWhisk</a>,
their new <a href="https://www.quora.com/What-is-Serverless-Computing">"serverless"</a>
compute platform.</p>

<p>This service allows developers to register small bits of
code that are executed on-demand in response to external events. The
"serverless" stack started in 2014, when Amazon launched
<a href="https://aws.amazon.com/lambda/">Lambda</a>, but is now set to be a major
technology trend in 2016 with IBM, Microsoft and Google all launching their own
solutions.</p>

<p>OpenWhisk is the first <a href="https://github.com/openwhisk/openwhisk">open-source "serverless" platform</a>. It supports running registered
actions in Node.js, Swift and even executing custom Docker containers.</p>

<p>Playing around with the technology recently, I've created two projects using the platform.</p>

<h2>OpenWhisk Client Library</h2>

<p>OpenWhisk exposes a <a href="https://github.com/openwhisk/openwhisk/blob/master/docs/reference.md#rest-api">RESTful API</a>
for interacting with the service. Wrapping this API with a
<a href="https://github.com/openwhisk/openwhisk-client-js">small client library</a> makes it easy for developers to interact with the service from JavaScript.</p>

<p>This library has been donated back to the OpenWhisk project and is <a href="https://www.npmjs.com/package/openwhisk">available through NPM</a>.</p>

<p><code>javascript
const openwhisk = require('openwhisk')
const ow = openwhisk({api: 'https://openwhisk.ng.bluemix.net/api/v1/', api_key: '...', namespace: '...'})
ow.actions.invoke({actionName: 'action'}).then(result =&gt; {
  // result is service response
})
</code></p>

<h2>Whiskify</h2>

<p>This <a href="https://github.com/jthomas/whiskify">project</a>, available through <a href="https://www.npmjs.com/package/openwhisk">NPM</a>, makes it easy to run arbitary JavaScript
functions as OpenWhisk actions.  Passing a reference to a JavaScript function
into the module, an OpenWhisk action is created using the function source.  The
module returns a new JavaScript function, that when executed, will call the
remote action and returns a Promise with the service response.</p>

<p>``` javascript
const whiskify = require('whiskify')({api: 'https://', api_key: '...', namespace: '...'})
const action = whiskify(function (item) { return item + 1; })</p>

<p>action(1).then(function (result) {
  // == 2
})</p>

<p>action.map([1, 2, 3, 4]).then(function (result) {
 // == [2, 3, 4, 5]
})</p>

<p>action.delete()
```</p>

<p>This project uses the client library above.</p>
]]></content>
  </entry>
  
</feed>
