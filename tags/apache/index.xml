<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>apache on notes on software.</title>
    <link>https://jamesthom.as/tags/apache/</link>
    <description>Recent content in apache on notes on software.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 14 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jamesthom.as/tags/apache/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Accessing Long-Running Apache OpenWhisk Actions Results</title>
      <link>https://jamesthom.as/2019/05/accessing-long-running-apache-openwhisk-actions-results/</link>
      <pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jamesthom.as/2019/05/accessing-long-running-apache-openwhisk-actions-results/</guid>
      <description>Apache OpenWhisk actions are invoked by sending HTTP POST requests to the platform API. Invocation requests have two different modes: blocking and non-blocking.
Blocking invocations mean the platform won&amp;rsquo;t send the HTTP response until the action finishes. This allows it to include the action result in the response. Blocking invocations are used when you want to invoke an action and wait for the result.
$ wsk action invoke my_action --blocking ok: invoked /_/my_action with id db70ef682fae4f8fb0ef682fae2f8fd5 { &amp;quot;activationId&amp;quot;: &amp;quot;db70ef682fae4f8fb0ef682fae2f8fd5&amp;quot;, .</description>
    </item>
    
    <item>
      <title>Saving Money and Time With Node.js Worker Threads in Serverless Functions</title>
      <link>https://jamesthom.as/2019/05/saving-money-and-time-with-node.js-worker-threads-in-serverless-functions/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jamesthom.as/2019/05/saving-money-and-time-with-node.js-worker-threads-in-serverless-functions/</guid>
      <description>Node.js v12 was released last month. This new version includes support for Worker Threads, that are enabled by default. Node.js Worker Threads make it simple to execute JavaScript code in parallel using threads. üëèüëèüëè
This is useful for Node.js applications with CPU-intensive workloads. Using Worker Threads, JavaScript code can be executed code concurrently using multiple CPU cores. This reduces execution time compared to a non-Worker Threads version.
If serverless platforms provide Node.</description>
    </item>
    
    <item>
      <title>Apache OpenWhisk Web Action HTTP Proxy</title>
      <link>https://jamesthom.as/2019/04/apache-openwhisk-web-action-http-proxy/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jamesthom.as/2019/04/apache-openwhisk-web-action-http-proxy/</guid>
      <description>What if you could take an existing web application and run it on a serverless platform with no changes? ü§î
Lots of existing (simple) stateless web applications are perfect candidates for serverless, but use web frameworks that don&amp;rsquo;t know how to integrate with those platforms. People have started to develop a number of custom plugins for those frameworks to try and bridge this gap.
These plugins can provide an easier learning curve for developers new to serverless.</description>
    </item>
    
    <item>
      <title>Serverless CI/CD with Travis CI, Serverless Framework and IBM Cloud Functions</title>
      <link>https://jamesthom.as/2019/04/serverless-ci/cd-with-travis-ci-serverless-framework-and-ibm-cloud-functions/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jamesthom.as/2019/04/serverless-ci/cd-with-travis-ci-serverless-framework-and-ibm-cloud-functions/</guid>
      <description>How do you set up a CI/CD pipeline for serverless applications?
This blog post will explain how to use Travis CI, The Serverless Framework and the AVA testing framework to set up a fully-automated build, deploy and test pipeline for a serverless application. It will use a real example of a production serverless application, built using Apache OpenWhisk and running on IBM Cloud Functions. The CI/CD pipeline will execute the following tasks&amp;hellip;</description>
    </item>
    
    <item>
      <title>Automating Apache OpenWhisk Releases With Serverless</title>
      <link>https://jamesthom.as/2019/04/automating-apache-openwhisk-releases-with-serverless/</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jamesthom.as/2019/04/automating-apache-openwhisk-releases-with-serverless/</guid>
      <description>This blog post explains how I used serverless functions to automate release candidate verification for the Apache OpenWhisk project.
Automating this process has the following benefits&amp;hellip;
 Removes the chance of human errors compared to the previously manual validation process. Allows me to validate new releases without access to my dev machine. Usable by all committers by hosting as an external serverless web app.  Automating release candidate validation makes it easier for project committers to participate in release voting.</description>
    </item>
    
  </channel>
</rss>