<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>node.js on notes on software.</title>
    <link>https://jamesthom.as/tags/node.js/</link>
    <description>Recent content in node.js on notes on software.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 22 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jamesthom.as/tags/node.js/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Connecting to IBM Cloud Databases for Redis from Node.js</title>
      <link>https://jamesthom.as/2019/07/connecting-to-ibm-cloud-databases-for-redis-from-node.js/</link>
      <pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jamesthom.as/2019/07/connecting-to-ibm-cloud-databases-for-redis-from-node.js/</guid>
      <description>This blog post explains how to connect to an IBM Cloud Databases for Redis instance from a Node.js application. There is a (small) difference between the connection details needed for an IBM Cloud Databases for Redis instance compared to a local instance of the open-source database. This is due to all IBM Cloud Databases using secured TLS connections with self-signed certificates.
I keep running into this issue (and forgetting how to fix it ü§¶‚Äç‚ôÇÔ∏è*), so I&amp;rsquo;m documenting the solution here to help myself (and others) who might run into it‚Ä¶* ü¶∏‚Äç‚ôÇÔ∏è</description>
    </item>
    
    <item>
      <title>Accessing Long-Running Apache OpenWhisk Actions Results</title>
      <link>https://jamesthom.as/2019/05/accessing-long-running-apache-openwhisk-actions-results/</link>
      <pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jamesthom.as/2019/05/accessing-long-running-apache-openwhisk-actions-results/</guid>
      <description>Apache OpenWhisk actions are invoked by sending HTTP POST requests to the platform API. Invocation requests have two different modes: blocking and non-blocking.
Blocking invocations mean the platform won&amp;rsquo;t send the HTTP response until the action finishes. This allows it to include the action result in the response. Blocking invocations are used when you want to invoke an action and wait for the result.
$ wsk action invoke my_action --blocking ok: invoked /_/my_action with id db70ef682fae4f8fb0ef682fae2f8fd5 { &amp;quot;activationId&amp;quot;: &amp;quot;db70ef682fae4f8fb0ef682fae2f8fd5&amp;quot;, .</description>
    </item>
    
    <item>
      <title>Saving Money and Time With Node.js Worker Threads in Serverless Functions</title>
      <link>https://jamesthom.as/2019/05/saving-money-and-time-with-node.js-worker-threads-in-serverless-functions/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jamesthom.as/2019/05/saving-money-and-time-with-node.js-worker-threads-in-serverless-functions/</guid>
      <description>Node.js v12 was released last month. This new version includes support for Worker Threads, that are enabled by default. Node.js Worker Threads make it simple to execute JavaScript code in parallel using threads. üëèüëèüëè
This is useful for Node.js applications with CPU-intensive workloads. Using Worker Threads, JavaScript code can be executed code concurrently using multiple CPU cores. This reduces execution time compared to a non-Worker Threads version.
If serverless platforms provide Node.</description>
    </item>
    
    <item>
      <title>Finding photos on Twitter using face recognition with TensorFlow.js</title>
      <link>https://jamesthom.as/2018/10/finding-photos-on-twitter-using-face-recognition-with-tensorflow.js/</link>
      <pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jamesthom.as/2018/10/finding-photos-on-twitter-using-face-recognition-with-tensorflow.js/</guid>
      <description>As a developer advocate, I spend a lot of time at developer conferences (talking about serverless üòé). Upon returning from each trip, I need to compile a &amp;ldquo;trip report&amp;rdquo; on the event for my bosses. This helps demonstrate the value in attending events and that I&amp;rsquo;m not just accruing air miles and hotel points for fun&amp;hellip; üõ´üè®
I always include any social media content people post about my talks in the trip report.</description>
    </item>
    
    <item>
      <title>Serverless Machine Learning With TensorFlow.js</title>
      <link>https://jamesthom.as/2018/08/serverless-machine-learning-with-tensorflow.js/</link>
      <pubDate>Mon, 13 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jamesthom.as/2018/08/serverless-machine-learning-with-tensorflow.js/</guid>
      <description>In a previous blog post, I showed how to use TensorFlow.js on Node.js to run visual recognition on images from the local filesystem. TensorFlow.js is a JavaScript version of the open-source machine learning library from Google.
Once I had this working with a local Node.js script, my next idea was to convert it into a serverless function. Running this function on IBM Cloud Functions (Apache OpenWhisk) would turn the script into my own visual recognition microservice.</description>
    </item>
    
    <item>
      <title>Machine Learning In Node.js With TensorFlow.js</title>
      <link>https://jamesthom.as/2018/08/machine-learning-in-node.js-with-tensorflow.js/</link>
      <pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jamesthom.as/2018/08/machine-learning-in-node.js-with-tensorflow.js/</guid>
      <description>TensorFlow.js is a new version of the popular open-source library which brings deep learning to JavaScript. Developers can now define, train, and run machine learning models using the high-level library API.
Pre-trained models mean developers can now easily perform complex tasks like visual recognition, generating music or detecting human poses with just a few lines of JavaScript.
Having started as a front-end library for web browsers, recent updates added experimental support for Node.</description>
    </item>
    
    <item>
      <title>Debugging Node.js OpenWhisk Actions</title>
      <link>https://jamesthom.as/2018/07/debugging-node.js-openwhisk-actions/</link>
      <pubDate>Tue, 10 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jamesthom.as/2018/07/debugging-node.js-openwhisk-actions/</guid>
      <description>Debugging serverless applications is one of the most challenging issues developers face when using serverless platforms. How can you use debugging tools without any access to the runtime environment?
Last week, I worked out how to expose the Node.js debugger in the Docker environment used for the application runtime in Apache OpenWhisk.
Want to use Node.js debugger for @openwhisk actions? Start runtime container locally with this command to expose v8 inspector.</description>
    </item>
    
  </channel>
</rss>